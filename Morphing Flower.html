<meta name="viewport" content="width=device-width, initial-scale=1.0, 
user-scalable=no">
<html>

<head>
  <style type="text/css">
    html,
    body {
      position: absolute !important;
      width: 100% !important;
      height: 100% !important;
      margin-left: 0px !important;
      margin-top: 0px !important;
      left: 0px !important;
      top: 0px !important;
    }
  </style>
  <script type="text/javascript">
    /* https://github.com/okTurtles/group-income/blob/master/contracts/0.0.9/group.js */
    // frontend/model/contracts/misc/flowTyper.js
    var EMPTY_VALUE = Symbol("@@empty");
    var isEmpty = (v) => v === EMPTY_VALUE;
    var isNil = (v) => v === null;
    var isUndef2 = (v) => typeof v === "undefined";
    var isBoolean2 = (v) => typeof v === "boolean";
    var isNumber = (v) => typeof v === "number";
    var isString = (v) => typeof v === "string";
    var isObject2 = (v) => !isNil(v) && typeof v === "object";
    var isFunction = (v) => typeof v === "function";
    var getType2 = (typeFn, _options) => {
      if (isFunction(typeFn.type))
        return typeFn.type(_options);
      return typeFn.name || "?";
    };
    var TypeValidatorError = class extends Error {
      expectedType;
      valueType;
      value;
      typeScope;
      sourceFile;
      constructor(message, expectedType, valueType, value, typeName = "", typeScope = "") {
        const errMessage = message || `invalid "${valueType}" value type; ${typeName || expectedType} type expected`;
        super(errMessage);
        this.expectedType = expectedType;
        this.valueType = valueType;
        this.value = value;
        this.typeScope = typeScope || "";
        this.sourceFile = this.getSourceFile();
        this.message = `${errMessage}
    ${this.getErrorInfo()}`;
        this.name = this.constructor.name;
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, TypeValidatorError);
        }
      }
      getSourceFile() {
        const fileNames = this.stack.match(/(\/[\w_\-.]+)+(\.\w+:\d+:\d+)/g) || [];
        return fileNames.find((fileName) => fileName.indexOf("/flowTyper-js/dist/") === -1) || "";
      }
      getErrorInfo() {
        return `
        file     ${this.sourceFile}
        scope    ${this.typeScope}
        expected ${this.expectedType.replace(/\n/g, "")}
        type     ${this.valueType}
        value    ${this.value}
    `;
      }
    };
    var validatorError = (typeFn, value, scope, message, expectedType, valueType) => {
      return new TypeValidatorError(message, expectedType || getType2(typeFn), valueType || typeof value, JSON.stringify(value), typeFn.name, scope);
    };
    var arrayOf = (typeFn, _scope = "Array") => {
      function array(value) {
        if (isEmpty(value))
          return [typeFn(value)];
        if (Array.isArray(value)) {
          let index2 = 0;
          return value.map((v) => typeFn(v, `${_scope}[${index2++}]`));
        }
        throw validatorError(array, value, _scope);
      }
      array.type = () => `Array<${getType2(typeFn)}>`;
      return array;
    };
    var literalOf = (primitive) => {
      function literal(value, _scope = "") {
        if (isEmpty(value) || value === primitive)
          return primitive;
        throw validatorError(literal, value, _scope);
      }
      literal.type = () => {
        if (isBoolean2(primitive))
          return `${primitive ? "true" : "false"}`;
        else
          return `"${primitive}"`;
      };
      return literal;
    };
    var mapOf = (keyTypeFn, typeFn) => {
      function mapOf2(value) {
        if (isEmpty(value))
          return {};
        const o = object(value);
        const reducer = (acc, key) => Object.assign(acc, {
          [keyTypeFn(key, "Map[_]")]: typeFn(o[key], `Map.${key}`)
        });
        return Object.keys(o).reduce(reducer, {});
      }
      mapOf2.type = () => `{ [_:${getType2(keyTypeFn)}]: ${getType2(typeFn)} }`;
      return mapOf2;
    };
    var object = function (value) {
      if (isEmpty(value))
        return {};
      if (isObject2(value) && !Array.isArray(value)) {
        return Object.assign({}, value);
      }
      throw validatorError(object, value);
    };
    var objectOf = (typeObj, _scope = "Object") => {
      function object2(value) {
        const o = object(value);
        const typeAttrs = Object.keys(typeObj);
        const unknownAttr = Object.keys(o).find((attr) => !typeAttrs.includes(attr));
        if (unknownAttr) {
          throw validatorError(object2, value, _scope, `missing object property '${unknownAttr}' in ${_scope} type`);
        }
        const undefAttr = typeAttrs.find((property) => {
          const propertyTypeFn = typeObj[property];
          return propertyTypeFn.name.includes("maybe") && !o.hasOwnProperty(property);
        });
        if (undefAttr) {
          throw validatorError(object2, o[undefAttr], `${_scope}.${undefAttr}`, `empty object property '${undefAttr}' for ${_scope} type`, `void | null | ${getType2(typeObj[undefAttr]).substr(1)}`, "-");
        }
        const reducer = isEmpty(value) ? (acc, key) => Object.assign(acc, { [key]: typeObj[key](value) }) : (acc, key) => {
          const typeFn = typeObj[key];
          if (typeFn.name.includes("optional") && !o.hasOwnProperty(key)) {
            return Object.assign(acc, {});
          } else {
            return Object.assign(acc, { [key]: typeFn(o[key], `${_scope}.${key}`) });
          }
        };
        return typeAttrs.reduce(reducer, {});
      }
      object2.type = () => {
        const props2 = Object.keys(typeObj).map((key) => {
          const ret = typeObj[key].name.includes("optional") ? `${key}?: ${getType2(typeObj[key], { noVoid: true })}` : `${key}: ${getType2(typeObj[key])}`;
          return ret;
        });
        return `{|
     ${props2.join(",\n  ")} 
    |}`;
      };
      return object2;
    };
    function objectMaybeOf(validations, _scope = "Object") {
      return function (data) {
        object(data);
        for (const key in data) {
          validations[key]?.(data[key], `${_scope}.${key}`);
        }
        return data;
      };
    }
    var optional = (typeFn) => {
      const unionFn = unionOf(typeFn, undef);
      function optional2(v) {
        return unionFn(v);
      }
      optional2.type = ({ noVoid }) => !noVoid ? getType2(unionFn) : getType2(typeFn);
      return optional2;
    };
    function undef(value, _scope = "") {
      if (isEmpty(value) || isUndef2(value))
        return void 0;
      throw validatorError(undef, value, _scope);
    }
    undef.type = () => "void";
    var boolean = function boolean2(value, _scope = "") {
      if (isEmpty(value))
        return false;
      if (isBoolean2(value))
        return value;
      throw validatorError(boolean2, value, _scope);
    };
    var number = function number2(value, _scope = "") {
      if (isEmpty(value))
        return 0;
      if (isNumber(value))
        return value;
      throw validatorError(number2, value, _scope);
    };
    var string = function string2(value, _scope = "") {
      if (isEmpty(value))
        return "";
      if (isString(value))
        return value;
      throw validatorError(string2, value, _scope);
    };
    function tupleOf_(...typeFuncs) {
      function tuple(value, _scope = "") {
        const cardinality = typeFuncs.length;
        if (isEmpty(value))
          return typeFuncs.map((fn) => fn(value));
        if (Array.isArray(value) && value.length === cardinality) {
          const tupleValue = [];
          for (let i = 0; i < cardinality; i += 1) {
            tupleValue.push(typeFuncs[i](value[i], _scope));
          }
          return tupleValue;
        }
        throw validatorError(tuple, value, _scope);
      }
      tuple.type = () => `[${typeFuncs.map((fn) => getType2(fn)).join(", ")}]`;
      return tuple;
    }
    var tupleOf = tupleOf_;
    function unionOf_(...typeFuncs) {
      function union(value, _scope = "") {
        for (const typeFn of typeFuncs) {
          try {
            return typeFn(value, _scope);
          } catch (_) {
          }
        }
        throw validatorError(union, value, _scope);
      }
      union.type = () => `(${typeFuncs.map((fn) => getType2(fn)).join(" | ")})`;
      return union;
    }
    var unionOf = unionOf_;

    // frontend/model/contracts/shared/constants.js
    var INVITE_INITIAL_CREATOR = "invite-initial-creator";
    var INVITE_STATUS = {
      REVOKED: "revoked",
      VALID: "valid",
      USED: "used"
    };
    var PROFILE_STATUS = {
      ACTIVE: "active",
      PENDING: "pending",
      REMOVED: "removed"
    };
    var PROPOSAL_RESULT = "proposal-result";
    var PROPOSAL_INVITE_MEMBER = "invite-member";
    var PROPOSAL_REMOVE_MEMBER = "remove-member";
    var PROPOSAL_GROUP_SETTING_CHANGE = "group-setting-change";
    var PROPOSAL_PROPOSAL_SETTING_CHANGE = "proposal-setting-change";
    var PROPOSAL_GENERIC = "generic";
    var PROPOSAL_ARCHIVED = "proposal-archived";
    var MAX_ARCHIVED_PROPOSALS = 100;
    var PAYMENTS_ARCHIVED = "payments-archived";
    var MAX_ARCHIVED_PERIODS = 100;
    var MAX_SAVED_PERIODS = 2;
    var STATUS_OPEN = "open";
    var STATUS_PASSED = "passed";
    var STATUS_FAILED = "failed";
    var STATUS_CANCELLED = "cancelled";
    var CHATROOM_TYPES = {
      INDIVIDUAL: "individual",
      GROUP: "group"
    };
    var CHATROOM_PRIVACY_LEVEL = {
      GROUP: "chatroom-privacy-level-group",
      PRIVATE: "chatroom-privacy-level-private",
      PUBLIC: "chatroom-privacy-level-public"
    };
    var MESSAGE_TYPES = {
      POLL: "message-poll",
      TEXT: "message-text",
      INTERACTIVE: "message-interactive",
      NOTIFICATION: "message-notification"
    };
    var INVITE_EXPIRES_IN_DAYS = {
      ON_BOARDING: 30,
      PROPOSAL: 7
    };
    var MESSAGE_NOTIFICATIONS = {
      ADD_MEMBER: "add-member",
      JOIN_MEMBER: "join-member",
      LEAVE_MEMBER: "leave-member",
      KICK_MEMBER: "kick-member",
      UPDATE_DESCRIPTION: "update-description",
      UPDATE_NAME: "update-name",
      DELETE_CHANNEL: "delete-channel",
      VOTE: "vote"
    };
    var PROPOSAL_VARIANTS = {
      CREATED: "proposal-created",
      EXPIRING: "proposal-expiring",
      ACCEPTED: "proposal-accepted",
      REJECTED: "proposal-rejected",
      EXPIRED: "proposal-expired"
    };
    var MAIL_TYPE_MESSAGE = "message";
    var MAIL_TYPE_FRIEND_REQ = "friend-request";
    // frontend/model/contracts/shared/payments/index.js
    var PAYMENT_PENDING = "pending";
    var PAYMENT_CANCELLED = "cancelled";
    var PAYMENT_ERROR = "error";
    var PAYMENT_NOT_RECEIVED = "not-received";
    var PAYMENT_COMPLETED = "completed";
    var paymentStatusType = unionOf(...[PAYMENT_PENDING, PAYMENT_CANCELLED, PAYMENT_ERROR, PAYMENT_NOT_RECEIVED, PAYMENT_COMPLETED].map((k) => literalOf(k)));
    var PAYMENT_TYPE_MANUAL = "manual";
    var PAYMENT_TYPE_BITCOIN = "bitcoin";
    var PAYMENT_TYPE_PAYPAL = "paypal";
    var paymentType = unionOf(...[PAYMENT_TYPE_MANUAL, PAYMENT_TYPE_BITCOIN, PAYMENT_TYPE_PAYPAL].map((k) => literalOf(k)));

    // frontend/model/contracts/shared/functions.js
    function paymentHashesFromPaymentPeriod(periodPayments) {
      let hashes = [];
      if (periodPayments) {
        const { paymentsFrom } = periodPayments;
        for (const fromUser in paymentsFrom) {
          for (const toUser in paymentsFrom[fromUser]) {
            hashes = hashes.concat(paymentsFrom[fromUser][toUser]);
          }
        }
      }
      return hashes;
    }
    function createPaymentInfo(paymentHash, payment) {
      return {
        from: payment.meta.username,
        to: payment.data.toUser,
        hash: paymentHash,
        amount: payment.data.amount,
        isLate: !!payment.data.isLate,
        when: payment.data.completedDate
      };
    }

    // frontend/model/contracts/shared/distribution/mincome-proportional.js
    function mincomeProportional(haveNeeds) {
      let totalHave = 0;
      let totalNeed = 0;
      const havers = [];
      const needers = [];
      for (const haveNeed of haveNeeds) {
        if (haveNeed.haveNeed > 0) {
          havers.push(haveNeed);
          totalHave += haveNeed.haveNeed;
        } else if (haveNeed.haveNeed < 0) {
          needers.push(haveNeed);
          totalNeed += Math.abs(haveNeed.haveNeed);
        }
      }
      const totalPercent = Math.min(1, totalNeed / totalHave);
      const payments = [];
      for (const haver of havers) {
        const distributionAmount = totalPercent * haver.haveNeed;
        for (const needer of needers) {
          const belowPercentage = Math.abs(needer.haveNeed) / totalNeed;
          payments.push({
            amount: distributionAmount * belowPercentage,
            from: haver.name,
            to: needer.name
          });
        }
      }
      return payments;
    }

    // frontend/model/contracts/shared/distribution/payments-minimizer.js
    function minimizeTotalPaymentsCount(distribution) {
      const neederTotalReceived = {};
      const haverTotalHave = {};
      const haversSorted = [];
      const needersSorted = [];
      const minimizedDistribution = [];
      for (const todo of distribution) {
        neederTotalReceived[todo.to] = (neederTotalReceived[todo.to] || 0) + todo.amount;
        haverTotalHave[todo.from] = (haverTotalHave[todo.from] || 0) + todo.amount;
      }
      for (const name in haverTotalHave) {
        haversSorted.push({ name, amount: haverTotalHave[name] });
      }
      for (const name in neederTotalReceived) {
        needersSorted.push({ name, amount: neederTotalReceived[name] });
      }
      haversSorted.sort((a, b) => b.amount - a.amount);
      needersSorted.sort((a, b) => b.amount - a.amount);
      while (haversSorted.length > 0 && needersSorted.length > 0) {
        const mostHaver = haversSorted.pop();
        const mostNeeder = needersSorted.pop();
        const diff = mostHaver.amount - mostNeeder.amount;
        if (diff < 0) {
          minimizedDistribution.push({ amount: mostHaver.amount, from: mostHaver.name, to: mostNeeder.name });
          mostNeeder.amount -= mostHaver.amount;
          needersSorted.push(mostNeeder);
        } else if (diff > 0) {
          minimizedDistribution.push({ amount: mostNeeder.amount, from: mostHaver.name, to: mostNeeder.name });
          mostHaver.amount -= mostNeeder.amount;
          haversSorted.push(mostHaver);
        } else {
          minimizedDistribution.push({ amount: mostNeeder.amount, from: mostHaver.name, to: mostNeeder.name });
        }
      }
      return minimizedDistribution;
    }

    // frontend/model/contracts/shared/currencies.js
    var DECIMALS_MAX = 8;
    function commaToDots(value) {
      return typeof value === "string" ? value.replace(/,/, ".") : value.toString();
    }
    function isNumeric(nr) {
      return !isNaN(nr - parseFloat(nr));
    }
    function isInDecimalsLimit(nr, decimalsMax) {
      const decimals = nr.split(".")[1];
      return !decimals || decimals.length <= decimalsMax;
    }
    function validateMincome(value, decimalsMax) {
      const nr = commaToDots(value);
      return isNumeric(nr) && isInDecimalsLimit(nr, decimalsMax);
    }
    function decimalsOrInt(num, decimalsMax) {
      return num.toFixed(decimalsMax).replace(/\.0+$/, "");
    }
    function saferFloat(value) {
      return parseFloat(value.toFixed(DECIMALS_MAX));
    }
    function makeCurrency(options) {
      const { symbol, symbolWithCode, decimalsMax, formatCurrency } = options;
      return {
        symbol,
        symbolWithCode,
        decimalsMax,
        displayWithCurrency: (n) => formatCurrency(decimalsOrInt(n, decimalsMax)),
        displayWithoutCurrency: (n) => decimalsOrInt(n, decimalsMax),
        validate: (n) => validateMincome(n, decimalsMax)
      };
    }
    var currencies = {
      USD: makeCurrency({
        symbol: "$",
        symbolWithCode: "$ USD",
        decimalsMax: 2,
        formatCurrency: (amount) => "$" + amount
      }),
      EUR: makeCurrency({
        symbol: "\u20AC",
        symbolWithCode: "\u20AC EUR",
        decimalsMax: 2,
        formatCurrency: (amount) => "\u20AC" + amount
      }),
      BTC: makeCurrency({
        symbol: "\u0243",
        symbolWithCode: "\u0243 BTC",
        decimalsMax: DECIMALS_MAX,
        formatCurrency: (amount) => amount + "\u0243"
      })
    };
    var currencies_default = currencies;

    // frontend/model/contracts/shared/distribution/distribution.js
    var tinyNum = 1 / Math.pow(10, DECIMALS_MAX);
    function unadjustedDistribution({ haveNeeds = [], minimize = true }) {
      const distribution = mincomeProportional(haveNeeds);
      return minimize ? minimizeTotalPaymentsCount(distribution) : distribution;
    }
    function adjustedDistribution({ distribution, payments, dueOn }) {
      distribution = cloneDeep(distribution);
      for (const todo of distribution) {
        todo.total = todo.amount;
      }
      distribution = subtractDistributions(distribution, payments).filter((todo) => todo.amount >= tinyNum);
      for (const todo of distribution) {
        todo.amount = saferFloat(todo.amount);
        todo.total = saferFloat(todo.total);
        todo.partial = todo.total !== todo.amount;
        todo.isLate = false;
        todo.dueOn = dueOn;
      }
      return distribution;
    }
    function reduceDistribution(payments) {
      payments = cloneDeep(payments);
      for (let i = 0; i < payments.length; i++) {
        const paymentA = payments[i];
        for (let j = i + 1; j < payments.length; j++) {
          const paymentB = payments[j];
          if (paymentA.from === paymentB.from && paymentA.to === paymentB.to || paymentA.to === paymentB.from && paymentA.from === paymentB.to) {
            paymentA.amount += (paymentA.from === paymentB.from ? 1 : -1) * paymentB.amount;
            paymentA.total += (paymentA.from === paymentB.from ? 1 : -1) * paymentB.total;
            payments.splice(j, 1);
            j--;
          }
        }
      }
      return payments;
    }
    function addDistributions(paymentsA, paymentsB) {
      return reduceDistribution([...paymentsA, ...paymentsB]);
    }
    function subtractDistributions(paymentsA, paymentsB) {
      paymentsB = cloneDeep(paymentsB);
      for (const p of paymentsB) {
        p.amount *= -1;
        p.total *= -1;
      }
      return addDistributions(paymentsA, paymentsB);
    }
  </script>
  <script type="text/javascript">
    function getFormat() {
      function File() { }
      File.prototype = function () {
        this.name = ""
        this.data = ""
      }
      function OpenGLDimension() {
        this.type = ""
        this.value = ""
        this.Type = {
          UNSET: "",
          SCREEN_SIZE: "SCREEN_SIZE",
          NEXT_LOWEST_POWER_OF_TWO: "NEXT_LOWEST_POWER_OF_TWO",
          NEXT_HIGHEST_POWER_OF_TWO: "NEXT_HIGHEST_POWER_OF_TWO",
          EXACT: "EXACT"
        }
      }
      OpenGLDimension.prototype = function () {
      }
      function OpenGLUniform() {
        this.type = ""
        this.name = ""
        this.value = ""
        this.Type = {
          UNSET: "",
          FLOAT: "FLOAT",
          INT: "INT",
          BOOL: "BOOL",
          VEC_TWO: "VEC_TWO",
          VEC_THREE: "VEC_THREE",
          VEC_FOUR: "VEC_FOUR",
          IVEC_TWO: "IVEC_TWO",
          IVEC_THREE: "IVEC_THREE",
          IVEC_FOUR: "IVEC_FOUR",
          BVEC_TWO: "BVEC_TWO",
          BVEC_THREE: "BVEC_THREE",
          BVEC_FOUR: "BVEC_FOUR",
          MAT_TWO: "MAT_TWO",
          MAT_THREE: "MAT_THREE",
          MAT_FOUR: "MAT_FOUR",
          SAMPLER_TWO_D: "SAMPLER_TWO_D",
          SAMPLERCUBE: "SAMPLERCUBE"
        }
      }
      OpenGLUniform.prototype = function () {
      }

      function OpenGLContext() {
        this.name = ""
        this.width = new OpenGLDimension()
        this.height = new OpenGLDimension()
        this.depth_test = false
      }
      OpenGLContext.prototype = function () {
      }

      function OpenGLProgram() {
        this.name = ""
        this.dynamics = [new GLSLJS()];
        this.uniforms = [new OpenGLUniform()]
        this.fragment = ""
        this.vertex = ""
      }

      OpenGLProgram.prototype = function () {
      }

      function GLSLJS() {
        this.name = ""
        this.value = ""
      }
      GLSLJS.prototype = function () {
      }


      function OpenGLStage() {
        this.name = ""
        this.type = ""
        this.context = ""
        this.program = ""
        this.vertices = ""
        this.indices = ""
        this.Type = {
          UNSET: "",
          SHADER: "SHADER",
          MESH_POINTS: "MESH_POINTS",
          MESH_LINES: "MESH_LINES",
          MESH_LINE_STRIP: "MESH_LINE_STRIP",
          MESH_LINE_LOOP: "MESH_LINE_LOOP",
          MESH_TRIANGLES: "MESH_TRIANGLES",
          MESH_TRIANGLE_FAN: "MESH_TRIANGLE_FAN",
          MESH_TRIANGLE_STRIP: "MESH_TRIANGLE_STRIP"
        }
      }
      OpenGLStage.prototype = function () {
      }

      function OpenGLPipeline() {
        this.contexts = [new OpenGLContext()]
        this.programs = [new OpenGLProgram()]
        this.stages = [new OpenGLStage()]
      }
      OpenGLPipeline.prototype = function () {
      }

      function Algorithm() {
        this.name = ""
        this.description = ""
        this.created = ""
        this.views = 0
        this.featured = false
        this.featured = false
        this.public = false
        this.html = ""
        this.client = ""
        this.files = [new File()]
        this.pipeline = new OpenGLPipeline()
        this.created = ""
        this.edited = ""
      }
      Algorithm.prototype = function () {
      }

      return {
        File: new File(),
        OpenGLDimension: new OpenGLDimension(),
        OpenGLUniform: new OpenGLUniform(),
        OpenGLContext: new OpenGLContext(),
        OpenGLProgram: new OpenGLProgram(),
        GLSLJS: new GLSLJS(),
        OpenGLStage: new OpenGLStage(),
        OpenGLPipeline: new OpenGLPipeline()
      }
      // Format.format = function(obj) {
      //   const final = {}
      //   for(const format in Format) {
      //     if()
      //     for(const key in Format.Algorithm) {
      //       if(typeof Format[key] === "string" && typeof obj[key] === "string") final[key].prototype = obj[key]
      //       else if(typeof Algorithm[key] === "boolean" && typeof obj[key] === "boolean") final[key].prototype =  obj[key]
      //       else if(typeof Array.isArray(Algorithm[key]) && Array.isArray(obj[key])) final[key].prototype = obj[key].map(Format.clean)
      //       else if(typeof Algorithm[key] === "object" && typeof obj[key] === "object") final[key].prototype = Format.clean(obj[key])
      //     }
      //   }
      // }
    }
    const Format = getFormat()
  </script>
  <script type="text/javascript">
    var default_fragment_shader =
      `
  #define GLSL_INSERTION_POINT
  `
    var default_vertex_shader =
      `
  #define GLSL_INSERTION_POINT
  `
    var userAlgorithm = null;

    var pipeline = null;

    var loadedCanvasCount;

    var promptStart, showLoading, hideError, hideLoading, saveAlgorithm, getListOfLanguages, voiceToText, translateLanguage, speakTextUsingGoogleSpeaker;

    var global_frequency, global_volume;

    function str2bin(str) {
      var result = [];
      for (var i = 0; i < str.length; i++) {
        result.push(str.charCodeAt(i));
      }
      return result;
    }

    function bin2str(array) {
      return String.fromCharCode.apply(String, array);
    }

    const OpenGLDimension = Format.OpenGLDimension
    const OpenGLUniform = Format.OpenGLUniform
    const GLSLJS = Format.GLSJS
    const OpenGLStageTypes = Format.OpenGLStage.Type;

    var is_safari = (navigator.userAgent.indexOf("iPhone") > -1 || navigator.userAgent.indexOf("iPad") > -1 || navigator.userAgent.indexOf("Safari") > -1) && navigator.userAgent.indexOf("Chrome") == -1;
    // var Auth, Image, Video, Sound, Person, Comment, MetaAlgorithm, 
    //     Query, Catalog, Vote, OpenGLDimension, OpenGLUniform, OpenGLContext, 
    //     OpenGLProgram, OpenGLStage, OpenGLPipeline, AlgorithmState, 
    //     Algorithm, Custom, Error, Captcha;

    window.requestAnimFrame = (function () {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function (/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {
          window.setTimeout(callback, 1000 / 60);
        };
    })();


    var api_names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];

    var OpenGLPipeline = function (pipleline_proto) { // "Constructor."
      this.currentContext = 0;
      this.contexts = [];

      if (pipleline_proto.contexts)
        for (var i = 0; i < pipleline_proto.contexts.length; i++) {
          this.addContext(pipleline_proto.contexts[i]);
          this.contexts[i].canvas.style.zIndex = i - pipleline_proto.contexts.length;
        }

      this.programs = [];
      this.cached_programs = [];

      if (pipleline_proto.programs)
        for (var i = 0; i < pipleline_proto.programs.length; i++)
          this.addProgram(pipleline_proto.programs[i]);

      this.stages = [];
      this.cached_stages = [];

      if (pipleline_proto.stages)
        for (var i = 0; i < pipleline_proto.stages.length; i++)
          this.addStage(pipleline_proto.stages[i]);
    };

    OpenGLPipeline.prototype.addContext = function (context_proto) {
      var context = new OpenGLContext(context_proto);
      this.contexts.push(context);
    };

    OpenGLPipeline.prototype.addProgram = function (program_proto) {
      var program = new OpenGLProgram(program_proto);
      this.programs.push(program);
    };

    OpenGLPipeline.prototype.addStage = function (stage_proto) {
      var stage = new OpenGLStage(stage_proto);
      this.stages.push(stage);
    };

    OpenGLPipeline.prototype.renderLoop = function () {
      this.currentContext++;
      this.anim = {
        renderLoop: (function (x) {
          if (window.renderLoop) window.renderLoop();
          this.render();
          if (x == this.currentContext)
            window.requestAnimationFrame(this.anim.renderLoop.bind(this.anim, x));
        }).bind(this)
      };
      this.anim.renderLoop(this.currentContext);
    }
    OpenGLPipeline.prototype.getProgram = function (name) {

      for (var i = 0; i < this.programs.length; i++)
        if (this.programs[i].program.name == name)
          return this.programs[i];
      return null;
    }
    OpenGLPipeline.prototype.getContext = function (name) {
      for (var i = 0; i < this.contexts.length; i++)
        if (this.contexts[i].context.name == name)
          return this.contexts[i];
      return null;
    }

    OpenGLPipeline.prototype.render = function (stage_name) {
      for (var i = 0; i < this.stages.length; i++) {
        if (stage_name && this.stages[i].stage.name != stage_name)
          continue;
        this.getContext(this.stages[i].stage.context).render(this.getProgram(this.stages[i].stage.program), this.stages[i]);
      }
    }

    OpenGLPipeline.prototype.destroy = function () {
      this.currentContext++;

      for (var i = 0; i < this.stages.length; i++)
        this.stages[i].destroy();

      this.stages = [];
    }

    OpenGLPipeline.prototype.setProto = function (new_proto) {

      //this.destroy();

      var new_contexts = new_proto.contexts;

      if (new_contexts) {
        this.contexts = []

        while (this.contexts.length < new_contexts.length)
          this.contexts.push(new OpenGLContext());


        for (var i = 0; i < new_contexts.length; i++)
          this.contexts[i].setProto(new_contexts[i]);
      }


      var new_programs = new_proto.programs;

      if (new_programs) {
        if (this.programs) {
          if (this.programs.length > new_programs.length) {
            var spliced = this.programs.splice(new_programs.length, this.programs.length - new_programs.length);
            for (var i = 0; i < spliced.length; i++)
              this.cached_programs.push(spliced[i]);
          }
          else if (this.programs.length == new_programs.length) {
            //NO OP
          }
          else {
            while (this.cached_programs.length > 0 && this.programs.length < new_programs.length)
              this.programs.push(this.cached_programs.splice(0, 1)[0]);
            while (this.programs.length < new_programs.length)
              this.programs.push(new OpenGLProgram());
          }

          for (var i = 0; i < new_programs.length; i++)
            this.programs[i].setProto(new_programs[i]);
        }
      }


      var new_stages = new_proto.stages;

      if (new_stages) {
        this.stages = []
        while (this.stages.length < new_stages.length)
          this.stages.push(new OpenGLStage());
        for (var i = 0; i < new_stages.length; i++)
          this.stages[i].setProto(new_stages[i]);
      }
    }

    var OpenGLContext = function (context_proto) { // "Constructor."

      this.context = context_proto ? context_proto : {};
      errorCode = { error: "", code: "" };
      this.gl = null;
      this.setProto(context_proto ? context_proto : {});
    };

    OpenGLContext.prototype.setProto = function (context_proto) {
      this.context = context_proto;

      if (!this.canvas) {
        this.canvas = document.createElement('canvas');
      }

      if (!context_proto.name) {
        var newId = 'canvas' + (new Date().getTime());
        this.canvas.id = newId;
        this.context.name = newId;
      }
      else {
        this.canvas.id = context_proto.name;
        this.context.name = context_proto.name;
      }

      if (!context_proto.width) {
        var newWidth = {}
        newWidth.type = OpenGLDimension.Type.SCREEN_SIZE;
        this.context.width = newWidth;
      }
      else {
        this.context.width = context_proto.width;
      }

      if (!context_proto.height) {
        var newHeight = {}
        newHeight.type = OpenGLDimension.Type.SCREEN_SIZE;
        this.context.height = newHeight;
      }
      else {
        this.context.height = context_proto.height;
      }


      if (context_proto.images)
        this.setImages(context_proto.images);

      this.textures = [];

      if (this.context.width.type == OpenGLDimension.Type.EXACT)
        this.cached_width_eval = new Function(this.context.width.value);

      if (this.context.height.type == OpenGLDimension.Type.EXACT)
        this.cached_height_eval = new Function(this.context.height.value);

      this.initGL();

      this.resizeCanvas();


      window.document.body.append(this.canvas)
    }


    OpenGLContext.prototype.setImages = function (images) {
      if (images)
        this.context.images = images;
      else
        this.context.images = [];

      this.refreshImages();
    };
    OpenGLContext.prototype.refreshImages = function () {
      this.img_elements = [];

      var x = document.getElementsByClassName("loaded-image");
      var i;
      for (i = 0; i < x.length; i++) {
        x[i].parentElement.removeChild(x[i]);
      }

      loadedCanvasCount = 0;
      for (var i = 0; i < this.context.images.length; i++) {
        var img = document.createElement('img');
        img.classList.add("loaded-image");
        img.id = "loaded-image" + i;
        this.img_elements.push(img)
        img.onload = (function () {
          if ((++loadedCanvasCount) == this.context.images.length) {
            this.refreshCanvases();
          }
        }).bind(this);
        var url = this.context.images[i].url ? this.context.images[i].url : bin2str(this.context.images[i].image);
        img.src = url;
      }
    }

    OpenGLContext.prototype.refreshCanvases = function () {
      this.canvases = [];
      for (var i = 0; i < this.context.images.length; i++) {
        var canvas = document.createElement('canvas');
        var img = this.img_elements[i];
        canvas.width = img.width;
        canvas.height = img.height;
        canvas.classList.add("loaded-image");
        canvas.id = "image-canvas" + i;

        var ctx = canvas.getContext("2d");

        ctx.drawImage(img, 0, 0);
        this.canvases.push(canvas);
      }
    }

    OpenGLContext.prototype.refreshImage = function (image) {
      try {
        var img = document.getElementById("loaded-image" + (image.index));
        var canvas = document.getElementById("image-canvas" + (image.index));
        canvas.width = img.width;
        canvas.height = img.height;

        var ctx = canvas.getContext("2d",
          {
            alpha: true,
            depth: this.context.depth_test,
            stencil: false,
            antialias: false,
            premultipliedAlpha: false,
            preserveDrawingBuffer: true,
            failIfMajorPerformanceCaveat: false
          });

        if (is_safari)
          ctx.transform(1, 0, 0, -1, 0, canvas.height)

        ctx.drawImage(img, 0, 0);
      }
      catch (e) {
        console.error("Error refreshing image: " + e);
      }
    }


    OpenGLContext.prototype.destroy = function () {
      var numTextureUnits = this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS);
      for (var unit = 0; unit < numTextureUnits; ++unit) {
        this.gl.activeTexture(this.gl.TEXTURE0 + unit);
        this.gl.bindTexture(this.gl.TEXTURE_2D, null);
        this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP, null);
      }
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);
      this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null);
      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);

      this.textures = [];
      this.gl.deleteBuffer(this.vertex_buffer);
      this.gl.deleteBuffer(this.index_buffer);
      delete this.canvas;
      this.canvas = null;
      delete this.gl;
      this.gl = null;
    }
    OpenGLContext.prototype.initGL = function () {
      this.time = 0;
      this.lastTime = 0;

      this.fpsElapsedTime = 0;
      this.fpsFrameCount = 0;
      this.fpsLastTime = new Date().getTime();
      if (this.canvas && !this.gl) {
        for (var ii = 0; ii < api_names.length; ++ii) {
          try {
            this.gl = this.canvas.getContext(api_names[ii],
              {
                alpha: true,
                depth: this.context.depth_test,
                stencil: false,
                antialias: false,
                premultipliedAlpha: false,
                preserveDrawingBuffer: true,
                failIfMajorPerformanceCaveat: false
              });
            this.gl.getExtension("OES_standard_derivatives");
            this.gl.getExtension("EXT_frag_depth");
            this.gl.getExtension('OES_texture_float');
            // this.glgetExtension('OES_texture_float_linear');
            // this.glgetExtension("OES_element_index_uint");
            // this.glgetExtension("WEBGL_color_buffer_float");
            // this.glgetExtension("EXT_color_buffer_float");
          } catch (e) { }
          if (this.gl) {
            break;
          }
        }
      }

      if (!this.gl) {
        errorCode = { report: "", code: "" };
        errorCode.report += "Could not initialise WebGL, sorry :-(";
        console.error(errorCode.report, errorCode.code);
        return;
      }

      if (!this.context.depth_test)
        this.gl.disable(this.gl.DEPTH_TEST);
      else
        this.gl.enable(this.gl.DEPTH_TEST);
    };


    OpenGLContext.prototype.resizeCanvas = function () {


      if (this.context.width.type == OpenGLDimension.Type.SCREEN_SIZE) {
        this.computed_width = window.innerWidth;
      }
      else if (this.context.width.type == OpenGLDimension.Type.NEXT_LOWEST_POWER_OF_TWO) {
        this.computed_width = Math.pow(2, Math.floor(Math.log(window.innerWidth) / Math.log(2.0)));
      }
      else if (this.context.width.type == OpenGLDimension.Type.NEXT_HIGHEST_POWER_OF_TWO) {
        this.computed_width = Math.pow(2, Math.floor(1. + Math.log(window.innerWidth) / Math.log(2.0)));
      }
      else if (this.context.width.type == OpenGLDimension.Type.EXACT) {
        this.computed_width = this.cached_width_eval.bind(this)(this);
      }

      if (this.context.height.type == OpenGLDimension.Type.SCREEN_SIZE) {
        this.computed_height = window.innerHeight
      }
      else if (this.context.height.type == OpenGLDimension.Type.NEXT_LOWEST_POWER_OF_TWO) {
        this.computed_height = Math.pow(2, Math.floor(Math.log(window.innerHeight) / Math.log(2.0)));
      }
      else if (this.context.height.type == OpenGLDimension.Type.NEXT_HIGHEST_POWER_OF_TWO) {
        this.computed_height = Math.pow(2, Math.floor(1. + Math.log(window.innerHeight) / Math.log(2.0)));
      }
      else if (this.context.height.type == OpenGLDimension.Type.EXACT) {
        this.computed_height = this.cached_height_eval.bind(this)(this);
      }
      this.canvas.width = this.computed_width;
      this.canvas.height = this.computed_height;

    };

    OpenGLContext.prototype.render = function (program, stage) {

      var now = new Date().getTime();
      this.fpsFrameCount++;
      this.fpsElapsedTime += (now - this.fpsLastTime);
      this.fpsLastTime = now;

      if (this.fpsFrameCount > 60) {
        var fps = this.fpsFrameCount / this.fpsElapsedTime * 1000.0;
        this.fpsFrameCount = 0;
        this.fpsElapsedTime = 0;
      }

      if (this.context.image && this.context.images) {

        if (this.reloadTextures) {

          for (var i = 0; i < this.context.images.length; i++)
            this.refreshImage(i);

          // for (var i = 0; i < this.textures.length; i++)
          //   this.gl.deleteTexture(this.textures[i]);
          // this.textures = [];

          // for (var i = 0; i < this.context.images.length; i++) {
          //   if (!this.img_elements[i])
          //     return;

          //   var texture = this.gl.createTexture();
          //   this.gl.bindTexture(this.gl.TEXTURE_2D, texture);

          //   // Set the parameters so we can render hany size image.
          //   this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
          //   this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
          //   this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
          //   this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);

          //   // Upload the image into the texture.
          //   this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.img_elements[i]);

          //   // add the texture to the array of textures.    
          //   this.textures.push(texture);
          // }
          this.reloadTextures = false;
        }
      }


      ////////////////////////////////////////////////////////////////////////////////////////////////////

      //this.gl.clear(this.gl.DEPTH_BUFFER_BIT | this.gl.COLOR_BUFFER_BIT);

      if (!this.cached_programs)
        this.cached_programs = {};

      if (program.dynamicsChanged(this) || !this.cached_programs[program.program.name + '-' + this.context.name]) {
        this.cached_programs[program.program.name + '-' + this.context.name] = program.getProgram(this);
        if (!this.cached_programs[program.program.name + '-' + this.context.name])
          throw new Error();
      }

      this.gl.useProgram(this.cached_programs[program.program.name + '-' + this.context.name]);
      stage.refreshGeometry(this, program);
      program.setUniforms(this, stage);
      this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
      stage.drawMesh(this, program);
    }

    var OpenGLProgram = function (program_proto) { // "Constructor."

      this.program = program_proto ? program_proto : {};
      errorCode = { error: "", code: "" };
      this.setProto(program_proto ? program_proto : {});
    };

    OpenGLProgram.prototype.setProto = function (program_proto) {
      this.program = program_proto;


      this.cached_uniform_evals = [];
      for (var i = 0; this.program.uniforms && i < this.program.uniforms.length; i++)
        this.cached_uniform_evals[i] = new Function(this.program.uniforms[i].value);
    }

    OpenGLProgram.prototype.setUniforms = function (context, stage) {
      var shader = context.cached_programs[this.program.name + '-' + context.context.name];
      for (var i = 0; (this.program.uniforms) && (this.cached_uniform_evals) && (i < this.program.uniforms.length) && (i < this.cached_uniform_evals.length); i++) {
        var location = context.gl.getUniformLocation(shader, this.program.uniforms[i].name);
        var type = this.program.uniforms[i].type;
        var value = this.cached_uniform_evals[i].bind(this)(context, this, stage);

        var type = this.program.uniforms[i].type;


        inner: switch (type) {
          case OpenGLUniform.Type.FLOAT:
            type = 'float';
            context.gl.uniform1f(location, value);
            break inner;
          case OpenGLUniform.Type.INT:
            type = 'int';
            context.gl.uniform1i(location, value);
            break inner;
          case OpenGLUniform.Type.BOOL:
            type = 'bool';
            context.gl.uniform1i(location, value);
            break inner;
          case OpenGLUniform.Type.VEC_TWO:
            type = 'vec2';
            context.gl.uniform2f(location, value[0], value[1]);
            break inner;
          case OpenGLUniform.Type.VEC_THREE:
            type = 'vec3';
            context.gl.uniform3f(location, value[0], value[1], value[2]);
            break inner;
          case OpenGLUniform.Type.VEC_FOUR:
            type = 'vec4';
            context.gl.uniform4f(location, value[0], value[1], value[2], value[3]);
            break inner;
          case OpenGLUniform.Type.IVEC_TWO:
            type = 'ivec2';
            context.gl.uniform2i(location, value[0], value[1]);
            break inner;
          case OpenGLUniform.Type.IVEC_THREE:
            type = 'ivec3';
            context.gl.uniform3i(location, value[0], value[1], value[2]);
            break inner;
          case OpenGLUniform.Type.IVEC_FOUR:
            type = 'ivec4';
            context.gl.uniform4i(location, value[0], value[1], value[2], value[3]);
            break inner;
          case OpenGLUniform.Type.BVEC_TWO:
            type = 'bvec2';
            context.gl.uniform2i(location, value[0], value[1]);
            break inner;
          case OpenGLUniform.Type.BVEC_THREE:
            type = 'bvec3';
            context.gl.uniform3i(location, value[0], value[1], value[2]);
            break inner;
          case OpenGLUniform.Type.BVEC_FOUR:
            type = 'bvec4';
            context.gl.uniform4i(location, value[0], value[1], value[2], value[3]);
            break inner;
          case OpenGLUniform.Type.MAT_TWO:
            type = 'mat2';
            context.gl.uniformMatrix2fv(location, false, value);
            break inner;
          case OpenGLUniform.Type.MAT_THREE:
            type = 'mat3';
            context.gl.uniformMatrix3fv(location, false, value);
            break inner;
          case OpenGLUniform.Type.MAT_FOUR:
            type = 'mat4';
            context.gl.uniformMatrix4fv(location, false, value);
            break inner;
          case OpenGLUniform.Type.SAMPLER_TWO_D:
            type = 'sampler2D';
            context.gl.uniform1i(location, value);
            break inner;
          case OpenGLUniform.Type.SAMPLERCUBE:
            type = 'samplerCube';
            context.gl.uniform1i(location, value);
            break inner;
        }
      }
    }


    OpenGLProgram.prototype.getUniforms = function () {
      var str = "";
      for (var i = 0; (this.program.uniforms) && (i < this.program.uniforms.length); i++) {
        var type = this.program.uniforms[i].type;


        inner: switch (type) {
          case OpenGLUniform.Type.FLOAT: type = 'float'; break inner;
          case OpenGLUniform.Type.INT: type = 'int'; break inner;
          case OpenGLUniform.Type.BOOL: type = 'bool'; break inner;
          case OpenGLUniform.Type.VEC_TWO: type = 'vec2'; break inner;
          case OpenGLUniform.Type.VEC_THREE: type = 'vec3'; break inner;
          case OpenGLUniform.Type.VEC_FOUR: type = 'vec4'; break inner;
          case OpenGLUniform.Type.IVEC_TWO: type = 'ivec2'; break inner;
          case OpenGLUniform.Type.IVEC_THREE: type = 'ivec3'; break inner;
          case OpenGLUniform.Type.IVEC_FOUR: type = 'ivec4'; break inner;
          case OpenGLUniform.Type.BVEC_TWO: type = 'bvec2'; break inner;
          case OpenGLUniform.Type.BVEC_THREE: type = 'bvec3'; break inner;
          case OpenGLUniform.Type.BVEC_FOUR: type = 'bvec4'; break inner;
          case OpenGLUniform.Type.MAT_TWO: type = 'mat2'; break inner;
          case OpenGLUniform.Type.MAT_THREE: type = 'mat3'; break inner;
          case OpenGLUniform.Type.MAT_FOUR: type = 'mat4'; break inner;
          case OpenGLUniform.Type.SAMPLER_TWO_D: type = 'sampler2D'; break inner;
          case OpenGLUniform.Type.SAMPLERCUBE: type = 'samplerCube'; break inner;
        }


        var name = this.program.uniforms[i].name;

        str += "uniform " + type + " " + name + ";\n";
      }
      return str;
    }


    OpenGLProgram.prototype.getTemplateVertexShader = function (context) {
      var str = default_vertex_shader + ""

      var delimeter = "#define GLSL_INSERTION_POINT";
      var head = str.substring(0, str.indexOf(delimeter));
      var tail = str.substring(str.indexOf(delimeter) + delimeter.length);
      var custom = this.program.vertex;

      str = head + "\n" + delimeter + "\n" + custom + "\n" + tail;

      delimeter = "#define UNIFORM_INSERTION_POINT";
      var line = str.indexOf(delimeter);
      if (line >= 0) {
        head = str.substring(0, line);
        tail = str.substring(line + delimeter.length);
        var uniforms = this.getUniforms();
        str = head + "\n" + delimeter + "\n" + uniforms + "\n" + tail;
      }

      var index = 0;
      if (this.program.dynamics) for (const glsljs of this.program.dynamics) {
        var value = this.program.cached_dynamic_strings[index]
        var delimeter = glsljs.name;
        var line = str.indexOf(delimeter);
        while (line >= 0) {
          head = str.substring(0, line);
          tail = str.substring(line + delimeter.length);
          str = head + value + tail;
          line = str.indexOf(delimeter)
        }
        index++;
      };

      var shader;
      shader = context.gl.createShader(context.gl.VERTEX_SHADER);

      context.gl.shaderSource(shader, str);
      context.gl.compileShader(shader);

      if (!context.gl.getShaderParameter(shader, context.gl.COMPILE_STATUS)) {
        errorCode.report += "Vertex Shader for CANVAS_ID=#" + this.program.canvas_id + " Error:\n\n";
        errorCode.report += context.gl.getShaderInfoLog(shader);
        errorCode.report += "\n\n\n";

        var transpiled = "";
        var lines = str.split('\n');

        for (var i = 0; i < lines.length; i++) {
          transpiled += (i + 1) + ":\t" + lines[i] + "\n";
        }

        errorCode.code += "Vertex Shader Code:\n\n";
        errorCode.code += transpiled;
        return null;
      }

      return shader;
    }
    OpenGLProgram.prototype.getTemplateFragmentShader = function (context) {
      var str = default_fragment_shader + ""

      var delimeter = "#define GLSL_INSERTION_POINT";
      var head = str.substring(0, str.indexOf(delimeter));
      var tail = str.substring(str.indexOf(delimeter) + delimeter.length);
      var custom = this.program.fragment;

      str = head + "\n" + delimeter + "\n" + custom + "\n" + tail;

      delimeter = "#define UNIFORM_INSERTION_POINT";
      var line = str.indexOf(delimeter);
      if (line >= 0) {
        head = str.substring(0, line);
        tail = str.substring(line + delimeter.length);
        var uniforms = this.getUniforms();
        str = head + "\n" + delimeter + "\n" + uniforms + "\n" + tail;
      }

      var index = 0;
      if (this.program.dynamics) for (const glsljs of this.program.dynamics) {
        var value = this.program.cached_dynamic_strings[index]
        var delimeter = glsljs.name;
        var line = str.indexOf(delimeter);
        while (line >= 0) {
          head = str.substring(0, line);
          tail = str.substring(line + delimeter.length);
          str = head + value + tail;
          line = str.indexOf(delimeter)
        }
        index++;
      };

      var shader;
      shader = context.gl.createShader(context.gl.FRAGMENT_SHADER);

      context.gl.shaderSource(shader, str);
      context.gl.compileShader(shader);

      if (!context.gl.getShaderParameter(shader, context.gl.COMPILE_STATUS)) {
        // alert(context.glgetShaderInfoLog(shader));
        errorCode.report += "Fragment Shader for CANVAS_ID=#" + this.program.canvas_id + " Error:\n\n";
        errorCode.report += context.gl.getShaderInfoLog(shader);
        errorCode.report += "\n\n\n";

        var transpiled = "";
        var lines = str.split('\n');

        for (var i = 0; i < lines.length; i++) {
          transpiled += (i + 1) + ":\t" + lines[i] + "\n";
        }

        errorCode.code += "Fragment Shader Code:\n\n";
        errorCode.code += transpiled;
        return null;
      }

      return shader;
    }
    OpenGLProgram.prototype.dynamicsChanged = function (context) {
      if (!this.program.cached_dynamic_strings) {
        this.program.cached_dynamic_functions = [];
        this.program.cached_dynamic_strings = [];
      }
      var updated = false;
      var index = 0;
      if (this.program.dynamics) for (const glsljs of this.program.dynamics) {
        this.program.cached_dynamic_functions[index] = new Function(glsljs.value);
        this.program.cached_dynamic_strings[index] = "";

        var value = this.program.cached_dynamic_functions[index]()
        if (this.program.cached_dynamic_strings[index] != value)
          updated = true;
        this.program.cached_dynamic_strings[index] = value;

        index++;
      };

      return updated;
    }
    OpenGLProgram.prototype.getProgram = function (context) {
      errorCode = { report: "", code: "" };
      var fragment_shader = this.getTemplateFragmentShader(context);
      if (!fragment_shader) {
        console.error(errorCode.report, errorCode.code);
        return;
      }

      var vertex_shader = this.getTemplateVertexShader(context);

      if (!vertex_shader) {
        console.error(errorCode.report, errorCode.code);
        return;
      }

      var shader_program = context.gl.createProgram();
      context.gl.attachShader(shader_program, fragment_shader);
      context.gl.attachShader(shader_program, vertex_shader);
      context.gl.linkProgram(shader_program);

      if (!context.gl.getProgramParameter(shader_program, context.gl.LINK_STATUS)) {
        errorCode.report += "\nUnable to link program!";
        context.gl.deleteProgram(shader_program);
        console.error(errorCode.report, errorCode.code);
      }

      context.gl.useProgram(shader_program);


      shader_program.vertexAttribute = context.gl.getAttribLocation(shader_program, "vertex");
      if (shader_program.vertexAttribute > -1)
        context.gl.enableVertexAttribArray(shader_program.vertexAttribute);

      shader_program.colorAttribute = context.gl.getAttribLocation(shader_program, "color");
      if (shader_program.colorAttribute > -1)
        context.gl.enableVertexAttribArray(shader_program.colorAttribute);

      shader_program.shapeAttribute = context.gl.getAttribLocation(shader_program, "shape");
      if (shader_program.shapeAttribute > -1)
        context.gl.enableVertexAttribArray(shader_program.shapeAttribute);


      return shader_program;
    }

    var OpenGLStage = function (stage_proto) { // "Constructor."

      this.stage = stage_proto ? stage_proto : {};
      this.setProto(stage_proto ? stage_proto : {});
    };
    OpenGLStage.prototype.setProto = function (stage_proto) {
      this.stage = stage_proto;

      this.cached_vertices = new Function(this.stage.vertices);
      this.cached_indices_eval = new Function(this.stage.indices);
    };

    OpenGLStage.prototype.drawMesh = function (context, program) {
      if (this.stage.type == OpenGLStageTypes.SHADER)
        context.gl.drawElements(context.gl.TRIANGLE_STRIP, this.index_buffer.numItems, context.gl.UNSIGNED_SHORT, 0);
      else if (this.stage.type == OpenGLStageTypes.MESH_POINTS)
        context.gl.drawElements(context.gl.POINTS, this.index_buffer.numItems, context.gl.UNSIGNED_SHORT, 0);
      else if (this.stage.type == OpenGLStageTypes.MESH_LINES)
        context.gl.drawElements(context.gl.LINES, this.index_buffer.numItems, context.gl.UNSIGNED_SHORT, 0);
      else if (this.stage.type == OpenGLStageTypes.MESH_LINE_STRIP)
        context.gl.drawElements(context.gl.LINE_STRIP, this.index_buffer.numItems, context.gl.UNSIGNED_SHORT, 0);
      else if (this.stage.type == OpenGLStageTypes.MESH_LINE_LOOP)
        context.gl.drawElements(context.gl.LINE_LOOP, this.index_buffer.numItems, context.gl.UNSIGNED_SHORT, 0);
      else if (this.stage.type == OpenGLStageTypes.MESH_TRIANGLES)
        context.gl.drawElements(context.gl.TRIANGLES, this.index_buffer.numItems, context.gl.UNSIGNED_SHORT, 0);
      else if (this.stage.type == OpenGLStageTypes.MESH_TRIANGLE_FAN)
        context.gl.drawElements(context.gl.TRIANGLE_FAN, this.index_buffer.numItems, context.gl.UNSIGNED_SHORT, 0);
      else if (this.stage.type == OpenGLStageTypes.MESH_TRIANGLE_STRIP)
        context.gl.drawElements(context.gl.TRIANGLE_STRIP, this.index_buffer.numItems, context.gl.UNSIGNED_SHORT, 0);
    };



    OpenGLStage.prototype.iniAttributeBuffers = function (context) {

      if (this.vertex_buffer)
        context.gl.deleteBuffer(this.vertex_buffer);
      if (this.color_buffer)
        context.gl.deleteBuffer(this.color_buffer);
      if (this.shape_buffer)
        context.gl.deleteBuffer(this.shape_buffer);
      if (this.index_buffer)
        context.gl.deleteBuffer(this.index_buffer);
      this.vertex_buffer = null;
      this.color_buffer = null;
      this.shape_buffer = null;
      this.index_buffer = null;
      this.vertex_buffer = context.gl.createBuffer();
      this.color_buffer = context.gl.createBuffer();
      this.shape_buffer = context.gl.createBuffer();
      this.index_buffer = context.gl.createBuffer();
    }

    OpenGLStage.prototype.refreshGeometry = function (context, program) {

      if (!this.vertex_buffer || !this.color_buffer || !this.shape_buffer || !this.index_buffer)
        this.iniAttributeBuffers(context);

      var new_vertices = null;
      var new_indices = null;

      if (this.stage.type == OpenGLStageTypes.SHADER) {
        new_vertices =
          [[
            0, 0, 0.0, 1.,
            context.computed_width, 0, 0.0, 1.,
            context.computed_width, context.computed_height, 0.0, 1.,
            0, context.computed_height, 0.0, 1.
          ]];
        new_indices = [
          0, 1, 2, 0, 2, 3// Front face
        ];
      }
      else {
        new_vertices = this.cached_vertices.bind(this)(context, program, this);
        new_indices = this.cached_indices_eval.bind(this)(context, program, this);
      }

      this.vertices = new_vertices;;
      this.indices = new_indices;;

      /*
      var update = false;
    
      if(!this.vertices || this.vertices.length!=new_vertices.length || !(this.vertices.every(function(v,i) { return v === new_vertices[i]; })))
      {
        this.vertices = new_vertices;;
        update = true;
      }
    
      if(!this.indices || this.indices.length!=new_indices.length || !(this.indices.every(function(v,i) { return v === new_indices[i]; })))
      {
        this.indices = new_indices;;
        update = true;
      }
      */

      //if(update)
      {

        this.vertex_buffer.itemSize = 4;
        this.color_buffer.itemSize = 4;
        this.shape_buffer.itemSize = 4;

        var shader = context.cached_programs[program.program.name + '-' + context.context.name];

        if (this.vertices.length > 0) {
          context.gl.bindBuffer(context.gl.ARRAY_BUFFER, this.vertex_buffer);
          context.gl.bufferData(context.gl.ARRAY_BUFFER, new Float32Array(this.vertices[0]), context.gl.DYNAMIC_DRAW);
          context.gl.enableVertexAttribArray(shader.vertexAttribute);
          context.gl.vertexAttribPointer(shader.vertexAttribute, this.vertex_buffer.itemSize, context.gl.FLOAT, false, 0, 0);
        }
        if (this.vertices.length > 1) {
          context.gl.bindBuffer(context.gl.ARRAY_BUFFER, this.color_buffer);
          context.gl.bufferData(context.gl.ARRAY_BUFFER, new Float32Array(this.vertices[1]), context.gl.DYNAMIC_DRAW);
          context.gl.enableVertexAttribArray(shader.colorAttribute);
          context.gl.vertexAttribPointer(shader.colorAttribute, this.color_buffer.itemSize, context.gl.FLOAT, false, 0, 0);
        }
        if (this.vertices.length > 2) {
          context.gl.bindBuffer(context.gl.ARRAY_BUFFER, this.shape_buffer);
          context.gl.bufferData(context.gl.ARRAY_BUFFER, new Float32Array(this.vertices[2]), context.gl.DYNAMIC_DRAW);
          context.gl.enableVertexAttribArray(shader.shapeAttribute);
          context.gl.vertexAttribPointer(shader.shapeAttribute, this.shape_buffer.itemSize, context.gl.FLOAT, false, 0, 0);
        }

        context.gl.bindBuffer(context.gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);
        context.gl.bufferData(context.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.indices), context.gl.DYNAMIC_DRAW);
        this.index_buffer.itemSize = 1;
        this.index_buffer.numItems = this.indices.length;
      }
    }
    var reloadTextures = false;

    function reload_algorithm() {
      if (!document || !document.body) return;
      document.body.innerHTML = ''

      if (pipeline) {
        //pipeline.destroy();
        if (userAlgorithm && userAlgorithm.pipeline)
          pipeline.setProto(userAlgorithm.pipeline)
      }
      else {
        if (userAlgorithm && userAlgorithm.pipeline)
          pipeline = new OpenGLPipeline(userAlgorithm.pipeline);
      }

      // if (userAlgorithm &&
      //   userAlgorithm.html) {
      //   $(document.body).append(userAlgorithm.html);
      // }

      // if (userAlgorithm != undefined &&
      //   userAlgorithm != null &&
      //   userAlgorithm.client != undefined) {
      //   document.head.innerHTML += '<script>' +
      //     userAlgorithm.client + "<script>";
      //   eval.call(window, userAlgorithm.client)
      // }

      if (pipeline)
        pipeline.renderLoop();
    }

    window.addEventListener('message', function (e) {
      try {
        if (e.data.compile) {
          userAlgorithm = JSON.parse(e.data.compile);
          reload_algorithm();
        } else if (e.data.execute) {
          eval.call(window, e.data.command);
        } else if (e.data.share) {
          window.parent.postMessage(JSON.stringify({ save: true, algorithm: userAlgorithm, hash: e.data.hash }), '*')
        }
      } catch (e) {
        console.debug(e.stack, e.message)
      }
    });

  </script>
  <script type="text/javascript">
    window.algorithm = {
      "name": "Morphing Flower",
      "description": "Mind melting.",
      "public": true,
      "files": [],
      "pipeline": {
        "contexts": [
          {
            "name": "output-context",
            "width": {
              "type": "SCREEN_SIZE",
              "value": ""
            },
            "height": {
              "type": "SCREEN_SIZE",
              "value": ""
            }
          }
        ],
        "programs": [
          {
            "name": "output-program",
            "uniforms": [
              {
                "type": "FLOAT",
                "value": "return (new Date().getTime()-window.startTime)/1E3;",
                "name": "time"
              },
              {
                "type": "FLOAT",
                "name": "width",
                "value": "return pipeline.getContext('output-context').canvas.width;"
              },
              {
                "type": "FLOAT",
                "name": "height",
                "value": "return pipeline.getContext('output-context').canvas.height;"
              }
            ],
            "fragment":
              `
#extension GL_OES_standard_derivatives : enable
precision highp float;
precision highp int;

#define UNIFORM_INSERTION_POINT

varying vec2 vPosition;
//-----------------CONSTANTS MACROS-----------------

#define PI 3.14159265359
#define E 2.7182818284
#define GR 1.61803398875
#define EPS .001

#define MAX_DIM (max(width,height))
#define time (sin(((sin(float(__LINE__)*100.0)*GR/PI+GR/PI/E)*time+100.0)/100.0)*100.0)
#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)

float cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }

float saw(float x)
{
    float f = mod(floor(abs(x)), 2.0);
    float m = mod(abs(x), 1.0);
    return f*(1.0-m)+(1.0-f)*m;
}
vec2 saw(vec2 x)
{
    return vec2(saw(x.x), saw(x.y));
}

vec3 saw(vec3 x)
{
    return vec3(saw(x.x), saw(x.y), saw(x.z));
}
vec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )
{
    vec2 res = vec2(-1.0);

    vec2 e = b-a;
    vec2 f = d-a;
    vec2 g = a-b+c-d;
    vec2 h = p-a;
        
    float k2 = cross2d( g, f );
    float k1 = cross2d( e, f ) + cross2d( h, g );
    float k0 = cross2d( h, e );
    
    // if edges are parallel, this is a linear equation. Do not this test here though, do
    // it in the user code
    if( abs(k2)<0.001 )
    {
        float v = -k0/k1;
        float u  = (h.x*k1+f.x*k0) / (e.x*k1-g.x*k0);
        //if( v>0.0 && v<1.0 && u>0.0 && u<1.0 ) 
            res = vec2( u, v );
    }
	else
    {
        // otherwise, it's a quadratic
        float w = k1*k1 - 4.0*k0*k2;
        //if( w<0.0 ) return vec2(-1.0);
        w = sqrt( w );

        float ik2 = 0.5/k2;
        float v = (-k1 - w)*ik2;// if( v<0.0 || v>1.0 ) v = (-k1 + w)*ik2;
        float u = (h.x - f.x*v)/(e.x + g.x*v);
        //if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) return vec2(-1.0);
        res = vec2( u, v );
    }
    return (res);
}


mat2 rotate(float x) { return mat2(cos(x), sin(x), sin(x), -cos(x)); }


float smooth_floor(float x)
{
	return x;//floor(x)+smoothstep(.75, 1., fract(x));
}

vec2 tree(vec2 uv)
{
    
    vec2 p = uv*2.-1.;
    
	
        float angle = smooth_floor((time))*PI/12.;

        vec2 a = vec2(1., 1.);
        vec2 b = vec2(0., 1.);
        vec2 c = vec2(0., 0.);
        vec2 d = vec2(1., 1./MAX_DIM);
        
        
        vec2 s = vec2(.75);
        vec2 o = vec2(smooth_floor(time/PI)/500., 0.);
        mat2 m = rotate(angle);
        
		a = a*2.-1.; b = b*2.-1.; c = c*2.-1.; d = d*2.-1.;
        
        a = a*m; b = b*m; c = c*m; d = d*m;
        a *= s; b *= s; c *= s; d *= s;
        a += o; b += o; c += o; d += o;

        
        /*
        //= a*.5+.5; b = b*.5+.5; c = c*.5+.5; d = d*.5+.5;
		a = a*2.-1.; b = b*2.-1.; c = c*2.-1.; d = d*2.-1.;
		*/

        vec2 a2 = a*vec2(-1., 1.);
        vec2 b2 = b*vec2(-1., 1.);
        vec2 c2 = c*vec2(-1., 1.);
        vec2 d2 = d*vec2(-1., 1.);
        if(p.x > 0.)
        	p = (invBilinear( p, a, b, c, d ));
        else
        	p = (invBilinear( p, a2, b2, c2, d2 ));
    return p;
}

vec2 flower(vec2 p)
{
	p *= rotate(time);
	float rots = 6.+1./MAX_DIM;
	float angle = atan(-p.y, -p.x);
	float radius = length(p);
	angle = floor(((angle/PI)*.5+.5)*rots);


	vec2 a = vec2(1., 0.);
	vec2 b = vec2(1., 1./MAX_DIM);
	vec2 c = vec2(0., 1./MAX_DIM);
	vec2 d = vec2(0., -1./MAX_DIM);
	
	b *= rotate(angle/rots*2.*PI);
	angle += 1.;
	a *= rotate(angle/rots*2.*PI);
	
	return (invBilinear( p, a, b, c, d ));
}


float square(vec2 uv, vec2 uv0)
{
    uv = (uv*2.-1.)*GR;
    return abs(saw(uv.y+uv0.x-uv0.y+time)-uv.x);
}


vec2 spiral(vec2 uv)
{
    float r = log(length(uv)+1.)/2.;
    float theta = atan(uv.y, uv.x)/PI-r*sin(time/E/PI/GR)/PI;
    return vec2(saw(r+time/E/E),
                saw(theta+time/GR/E))*2.-1.;
}

vec3 phase(float map)
{
    return vec3(sin(map),
                sin(4.0*PI/3.0+map),
                sin(2.0*PI/3.0+map))*.5+.5;
}

void main()
{
    vec2 uv = vec2(vPosition.x, 1.-vPosition.y);
    vec2 uv0 = uv.xy*2.-1.;
    uv0.x *= max(width/height, 1.);
    uv0.y *= max(height/width, 1.);
	uv0 = uv0*.5+.5;
    float map = 0.0;
    
    float lambda = 4.0;
	const int max_iterations = 12;

    float scale = 3.0*PI+(time*PI*GR*E);
    uv *= scale;
    uv -= scale/2.0;
    uv.x *= max(width/height, 1.);
    uv.y *= max(height/width, 1.);
    uv.xy += vec2(cos(time*.234),
                  sin(time*.345))*scale/2.;
	float m = smoothstep(0.45, .55, saw(time/E/PI));
    uv.xy = spiral(uv.xy*scale)*m+(1.-m)*(uv0);;
    
	float nature = smoothstep(.025, .125, saw(time/GR/E))*(1.-m);
	uv =  uv*(1.-nature)+flower(uv0*2.-1.)*nature;
	
    for(int i = 0; i <= max_iterations; i++)
    {
    	float iteration = (float(i)/(float(max_iterations) ));
        uv.xy = saw(tree(uv.xy));
			map += square(uv.xy, uv0);
		uv0 = uv;
    }
    
    float w = smoothstep(saw(map/float(max_iterations)+time), .0, .2);
    float b = smoothstep(saw(map/float(max_iterations)+time), .0, .2);
    gl_FragColor.rgb = (flux(map))*
        			
        			clamp(map, 0.0, 1.0);
    gl_FragColor.a = 1.0;
}`,
            "vertex": `
precision highp float;
precision highp int;

#define UNIFORM_INSERTION_POINT

attribute highp vec4 vertex; 

varying vec2 vPosition;
void main(void) {
    gl_PointSize = 2.;
    vPosition = vertex.xy;
    gl_Position = vec4(vertex.xy*2.-1., 0., 1.);
}`,
            "cached_dynamic_functions": [],
            "cached_dynamic_strings": []
          }
        ],
        "stages": [
          {
            "name": "output-stage",
            "context": "output-context",
            "program": "output-program",
            "type": "SHADER"
          }
        ]
      },
      "created": "Tue Oct 25 2022 02:09:16 GMT-0400 (Eastern Daylight Time)"
    };
    window.userAlgorithm = window.algorithm
    window.onload = () => { 
      reload_algorithm() 
      window.startTime = new Date().getTime()
      window.onresize = (e) => {
           var context = document.getElementById("output-context");
           context.width = e.target.innerWidth;
           context.height = e.target.innerHeight;
      }
    };
  </script>
</head>

<body>
</body>

</html>