<meta name="viewport" content="width=device-width, initial-scale=1.0, 
user-scalable=no">
<html>

<head>
  <style type="text/css">
    * {
      font-family: 'Roboto', sans-serif;
      font-weight: bold !important;
      font-size: 16px !important;
    }

    body,
    html {
      position: absolute;
      height: 100%;
      width: 100%;
      background-color: #fff;
      overflow: hidden;
      color: #fff;
    }

    button,
    label {
      font-weight: bold;
      vertical-align: middle;
      background-color: #77f !important;
      color: #fff !important;
      border-width: 3px !important;
      border-radius: 10px !important;
      border-color: #77f;
    }

    label {
      background-color: #fff !important;
      color: #000 !important;
    }

    button:hover {
      cursor: pointer;
      background-color: #fff !important;
      color: #000 !important;
    }

    button {
      width: fit-content;
      margin: auto !important;
      border-width: 3px !important;
      border-radius: 10px !important;
      border-color: #48f !important;
    }

    button,
    label {
      padding: 3px;
      border: 1px solid #77f;
    }

    .label_div,
    #options_div {
      color: #000;
      position: absolute;
      background-color: rgba(255,255,255,.75);
      border: 1px solid#77f;
      text-align: center;
      z-index: 10;
    }

    #controls_div>button {
      font-size: 24px !important;
    }

    #top_div {
      position: relative;
      width: 100%;
      height: 15%;
    }

    #canvas_div {
      position: relative;
      width: 100%;
      height: 75%;
    }

    #image-context {
      z-index: 2!important;
    }

    #bottom_div {
      position: relative;
      width: 100%;
      height: 10%;
    }
  </style>
  <script type="text/javascript">
    /* https://github.com/okTurtles/group-income/blob/master/contracts/0.0.9/group.js */
    // frontend/model/contracts/misc/flowTyper.js
    var EMPTY_VALUE = Symbol("@@empty");
    var isEmpty = (v) => v === EMPTY_VALUE;
    var isNil = (v) => v === null;
    var isUndef2 = (v) => typeof v === "undefined";
    var isBoolean2 = (v) => typeof v === "boolean";
    var isNumber = (v) => typeof v === "number";
    var isString = (v) => typeof v === "string";
    var isObject2 = (v) => !isNil(v) && typeof v === "object";
    var isFunction = (v) => typeof v === "function";
    var getType2 = (typeFn, _options) => {
      if (isFunction(typeFn.type))
        return typeFn.type(_options);
      return typeFn.name || "?";
    };
    var TypeValidatorError = class extends Error {
      expectedType;
      valueType;
      value;
      typeScope;
      sourceFile;
      constructor(message, expectedType, valueType, value, typeName = "", typeScope = "") {
        const errMessage = message || `invalid "${valueType}" value type; ${typeName || expectedType} type expected`;
        super(errMessage);
        this.expectedType = expectedType;
        this.valueType = valueType;
        this.value = value;
        this.typeScope = typeScope || "";
        this.sourceFile = this.getSourceFile();
        this.message = `${errMessage}
    ${this.getErrorInfo()}`;
        this.name = this.constructor.name;
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, TypeValidatorError);
        }
      }
      getSourceFile() {
        const fileNames = this.stack.match(/(\/[\w_\-.]+)+(\.\w+:\d+:\d+)/g) || [];
        return fileNames.find((fileName) => fileName.indexOf("/flowTyper-js/dist/") === -1) || "";
      }
      getErrorInfo() {
        return `
        file     ${this.sourceFile}
        scope    ${this.typeScope}
        expected ${this.expectedType.replace(/\n/g, "")}
        type     ${this.valueType}
        value    ${this.value}
    `;
      }
    };
    var validatorError = (typeFn, value, scope, message, expectedType, valueType) => {
      return new TypeValidatorError(message, expectedType || getType2(typeFn), valueType || typeof value, JSON.stringify(value), typeFn.name, scope);
    };
    var arrayOf = (typeFn, _scope = "Array") => {
      function array(value) {
        if (isEmpty(value))
          return [typeFn(value)];
        if (Array.isArray(value)) {
          let index2 = 0;
          return value.map((v) => typeFn(v, `${_scope}[${index2++}]`));
        }
        throw validatorError(array, value, _scope);
      }
      array.type = () => `Array<${getType2(typeFn)}>`;
      return array;
    };
    var literalOf = (primitive) => {
      function literal(value, _scope = "") {
        if (isEmpty(value) || value === primitive)
          return primitive;
        throw validatorError(literal, value, _scope);
      }
      literal.type = () => {
        if (isBoolean2(primitive))
          return `${primitive ? "true" : "false"}`;
        else
          return `"${primitive}"`;
      };
      return literal;
    };
    var mapOf = (keyTypeFn, typeFn) => {
      function mapOf2(value) {
        if (isEmpty(value))
          return {};
        const o = object(value);
        const reducer = (acc, key) => Object.assign(acc, {
          [keyTypeFn(key, "Map[_]")]: typeFn(o[key], `Map.${key}`)
        });
        return Object.keys(o).reduce(reducer, {});
      }
      mapOf2.type = () => `{ [_:${getType2(keyTypeFn)}]: ${getType2(typeFn)} }`;
      return mapOf2;
    };
    var object = function (value) {
      if (isEmpty(value))
        return {};
      if (isObject2(value) && !Array.isArray(value)) {
        return Object.assign({}, value);
      }
      throw validatorError(object, value);
    };
    var objectOf = (typeObj, _scope = "Object") => {
      function object2(value) {
        const o = object(value);
        const typeAttrs = Object.keys(typeObj);
        const unknownAttr = Object.keys(o).find((attr) => !typeAttrs.includes(attr));
        if (unknownAttr) {
          throw validatorError(object2, value, _scope, `missing object property '${unknownAttr}' in ${_scope} type`);
        }
        const undefAttr = typeAttrs.find((property) => {
          const propertyTypeFn = typeObj[property];
          return propertyTypeFn.name.includes("maybe") && !o.hasOwnProperty(property);
        });
        if (undefAttr) {
          throw validatorError(object2, o[undefAttr], `${_scope}.${undefAttr}`, `empty object property '${undefAttr}' for ${_scope} type`, `void | null | ${getType2(typeObj[undefAttr]).substr(1)}`, "-");
        }
        const reducer = isEmpty(value) ? (acc, key) => Object.assign(acc, { [key]: typeObj[key](value) }) : (acc, key) => {
          const typeFn = typeObj[key];
          if (typeFn.name.includes("optional") && !o.hasOwnProperty(key)) {
            return Object.assign(acc, {});
          } else {
            return Object.assign(acc, { [key]: typeFn(o[key], `${_scope}.${key}`) });
          }
        };
        return typeAttrs.reduce(reducer, {});
      }
      object2.type = () => {
        const props2 = Object.keys(typeObj).map((key) => {
          const ret = typeObj[key].name.includes("optional") ? `${key}?: ${getType2(typeObj[key], { noVoid: true })}` : `${key}: ${getType2(typeObj[key])}`;
          return ret;
        });
        return `{|
     ${props2.join(",\n  ")} 
    |}`;
      };
      return object2;
    };
    function objectMaybeOf(validations, _scope = "Object") {
      return function (data) {
        object(data);
        for (const key in data) {
          validations[key]?.(data[key], `${_scope}.${key}`);
        }
        return data;
      };
    }
    var optional = (typeFn) => {
      const unionFn = unionOf(typeFn, undef);
      function optional2(v) {
        return unionFn(v);
      }
      optional2.type = ({ noVoid }) => !noVoid ? getType2(unionFn) : getType2(typeFn);
      return optional2;
    };
    function undef(value, _scope = "") {
      if (isEmpty(value) || isUndef2(value))
        return void 0;
      throw validatorError(undef, value, _scope);
    }
    undef.type = () => "void";
    var boolean = function boolean2(value, _scope = "") {
      if (isEmpty(value))
        return false;
      if (isBoolean2(value))
        return value;
      throw validatorError(boolean2, value, _scope);
    };
    var number = function number2(value, _scope = "") {
      if (isEmpty(value))
        return 0;
      if (isNumber(value))
        return value;
      throw validatorError(number2, value, _scope);
    };
    var string = function string2(value, _scope = "") {
      if (isEmpty(value))
        return "";
      if (isString(value))
        return value;
      throw validatorError(string2, value, _scope);
    };
    function tupleOf_(...typeFuncs) {
      function tuple(value, _scope = "") {
        const cardinality = typeFuncs.length;
        if (isEmpty(value))
          return typeFuncs.map((fn) => fn(value));
        if (Array.isArray(value) && value.length === cardinality) {
          const tupleValue = [];
          for (let i = 0; i < cardinality; i += 1) {
            tupleValue.push(typeFuncs[i](value[i], _scope));
          }
          return tupleValue;
        }
        throw validatorError(tuple, value, _scope);
      }
      tuple.type = () => `[${typeFuncs.map((fn) => getType2(fn)).join(", ")}]`;
      return tuple;
    }
    var tupleOf = tupleOf_;
    function unionOf_(...typeFuncs) {
      function union(value, _scope = "") {
        for (const typeFn of typeFuncs) {
          try {
            return typeFn(value, _scope);
          } catch (_) {
          }
        }
        throw validatorError(union, value, _scope);
      }
      union.type = () => `(${typeFuncs.map((fn) => getType2(fn)).join(" | ")})`;
      return union;
    }
    var unionOf = unionOf_;

    // frontend/model/contracts/shared/constants.js
    var INVITE_INITIAL_CREATOR = "invite-initial-creator";
    var INVITE_STATUS = {
      REVOKED: "revoked",
      VALID: "valid",
      USED: "used"
    };
    var PROFILE_STATUS = {
      ACTIVE: "active",
      PENDING: "pending",
      REMOVED: "removed"
    };
    var PROPOSAL_RESULT = "proposal-result";
    var PROPOSAL_INVITE_MEMBER = "invite-member";
    var PROPOSAL_REMOVE_MEMBER = "remove-member";
    var PROPOSAL_GROUP_SETTING_CHANGE = "group-setting-change";
    var PROPOSAL_PROPOSAL_SETTING_CHANGE = "proposal-setting-change";
    var PROPOSAL_GENERIC = "generic";
    var PROPOSAL_ARCHIVED = "proposal-archived";
    var MAX_ARCHIVED_PROPOSALS = 100;
    var PAYMENTS_ARCHIVED = "payments-archived";
    var MAX_ARCHIVED_PERIODS = 100;
    var MAX_SAVED_PERIODS = 2;
    var STATUS_OPEN = "open";
    var STATUS_PASSED = "passed";
    var STATUS_FAILED = "failed";
    var STATUS_CANCELLED = "cancelled";
    var CHATROOM_TYPES = {
      INDIVIDUAL: "individual",
      GROUP: "group"
    };
    var CHATROOM_PRIVACY_LEVEL = {
      GROUP: "chatroom-privacy-level-group",
      PRIVATE: "chatroom-privacy-level-private",
      PUBLIC: "chatroom-privacy-level-public"
    };
    var MESSAGE_TYPES = {
      POLL: "message-poll",
      TEXT: "message-text",
      INTERACTIVE: "message-interactive",
      NOTIFICATION: "message-notification"
    };
    var INVITE_EXPIRES_IN_DAYS = {
      ON_BOARDING: 30,
      PROPOSAL: 7
    };
    var MESSAGE_NOTIFICATIONS = {
      ADD_MEMBER: "add-member",
      JOIN_MEMBER: "join-member",
      LEAVE_MEMBER: "leave-member",
      KICK_MEMBER: "kick-member",
      UPDATE_DESCRIPTION: "update-description",
      UPDATE_NAME: "update-name",
      DELETE_CHANNEL: "delete-channel",
      VOTE: "vote"
    };
    var PROPOSAL_VARIANTS = {
      CREATED: "proposal-created",
      EXPIRING: "proposal-expiring",
      ACCEPTED: "proposal-accepted",
      REJECTED: "proposal-rejected",
      EXPIRED: "proposal-expired"
    };
    var MAIL_TYPE_MESSAGE = "message";
    var MAIL_TYPE_FRIEND_REQ = "friend-request";
    // frontend/model/contracts/shared/payments/index.js
    var PAYMENT_PENDING = "pending";
    var PAYMENT_CANCELLED = "cancelled";
    var PAYMENT_ERROR = "error";
    var PAYMENT_NOT_RECEIVED = "not-received";
    var PAYMENT_COMPLETED = "completed";
    var paymentStatusType = unionOf(...[PAYMENT_PENDING, PAYMENT_CANCELLED, PAYMENT_ERROR, PAYMENT_NOT_RECEIVED, PAYMENT_COMPLETED].map((k) => literalOf(k)));
    var PAYMENT_TYPE_MANUAL = "manual";
    var PAYMENT_TYPE_BITCOIN = "bitcoin";
    var PAYMENT_TYPE_PAYPAL = "paypal";
    var paymentType = unionOf(...[PAYMENT_TYPE_MANUAL, PAYMENT_TYPE_BITCOIN, PAYMENT_TYPE_PAYPAL].map((k) => literalOf(k)));

    // frontend/model/contracts/shared/functions.js
    function paymentHashesFromPaymentPeriod(periodPayments) {
      let hashes = [];
      if (periodPayments) {
        const { paymentsFrom } = periodPayments;
        for (const fromUser in paymentsFrom) {
          for (const toUser in paymentsFrom[fromUser]) {
            hashes = hashes.concat(paymentsFrom[fromUser][toUser]);
          }
        }
      }
      return hashes;
    }
    function createPaymentInfo(paymentHash, payment) {
      return {
        from: payment.meta.username,
        to: payment.data.toUser,
        hash: paymentHash,
        amount: payment.data.amount,
        isLate: !!payment.data.isLate,
        when: payment.data.completedDate
      };
    }

    // frontend/model/contracts/shared/distribution/mincome-proportional.js
    function mincomeProportional(haveNeeds) {
      let totalHave = 0;
      let totalNeed = 0;
      const pledgers = [];
      const receivers = [];
      for (const haveNeed of haveNeeds) {
        if (haveNeed.haveNeed > 0) {
          pledgers.push(haveNeed);
          totalHave += haveNeed.haveNeed;
        } else if (haveNeed.haveNeed < 0) {
          receivers.push(haveNeed);
          totalNeed += Math.abs(haveNeed.haveNeed);
        }
      }
      const totalPercent = Math.min(1, totalNeed / totalHave);
      const payments = [];
      for (const pledger of pledgers) {
        const distributionAmount = totalPercent * pledger.haveNeed;
        for (const receiver of receivers) {
          const belowPercentage = Math.abs(receiver.haveNeed) / totalNeed;
          payments.push({
            amount: distributionAmount * belowPercentage,
            from: pledger.name,
            to: receiver.name
          });
        }
      }
      return payments;
    }

    // frontend/model/contracts/shared/distribution/payments-minimizer.js
    function minimizeTotalPaymentsCount(distribution) {
      const receiverTotalReceived = {};
      const pledgerTotalHave = {};
      const pledgersSorted = [];
      const receiversSorted = [];
      const minimizedDistribution = [];
      for (const todo of distribution) {
        receiverTotalReceived[todo.to] = (receiverTotalReceived[todo.to] || 0) + todo.amount;
        pledgerTotalHave[todo.from] = (pledgerTotalHave[todo.from] || 0) + todo.amount;
      }
      for (const name in pledgerTotalHave) {
        pledgersSorted.push({ name, amount: pledgerTotalHave[name] });
      }
      for (const name in receiverTotalReceived) {
        receiversSorted.push({ name, amount: receiverTotalReceived[name] });
      }
      pledgersSorted.sort((a, b) => b.amount - a.amount);
      receiversSorted.sort((a, b) => b.amount - a.amount);
      while (pledgersSorted.length > 0 && receiversSorted.length > 0) {
        const mostPledger = pledgersSorted.pop();
        const mostReceiver = receiversSorted.pop();
        const diff = mostPledger.amount - mostReceiver.amount;
        if (diff < 0) {
          minimizedDistribution.push({ amount: mostPledger.amount, from: mostPledger.name, to: mostReceiver.name });
          mostReceiver.amount -= mostPledger.amount;
          receiversSorted.push(mostReceiver);
        } else if (diff > 0) {
          minimizedDistribution.push({ amount: mostReceiver.amount, from: mostPledger.name, to: mostReceiver.name });
          mostPledger.amount -= mostReceiver.amount;
          pledgersSorted.push(mostPledger);
        } else {
          minimizedDistribution.push({ amount: mostReceiver.amount, from: mostPledger.name, to: mostReceiver.name });
        }
      }
      return minimizedDistribution;
    }

    // frontend/model/contracts/shared/currencies.js
    var DECIMALS_MAX = 8;
    function commaToDots(value) {
      return typeof value === "string" ? value.replace(/,/, ".") : value.toString();
    }
    function isNumeric(nr) {
      return !isNaN(nr - parseFloat(nr));
    }
    function isInDecimalsLimit(nr, decimalsMax) {
      const decimals = nr.split(".")[1];
      return !decimals || decimals.length <= decimalsMax;
    }
    function validateMincome(value, decimalsMax) {
      const nr = commaToDots(value);
      return isNumeric(nr) && isInDecimalsLimit(nr, decimalsMax);
    }
    function decimalsOrInt(num, decimalsMax) {
      return num.toFixed(decimalsMax).replace(/\.0+$/, "");
    }
    function saferFloat(value) {
      return parseFloat(value.toFixed(DECIMALS_MAX));
    }
    function makeCurrency(options) {
      const { symbol, symbolWithCode, decimalsMax, formatCurrency } = options;
      return {
        symbol,
        symbolWithCode,
        decimalsMax,
        displayWithCurrency: (n) => formatCurrency(decimalsOrInt(n, decimalsMax)),
        displayWithoutCurrency: (n) => decimalsOrInt(n, decimalsMax),
        validate: (n) => validateMincome(n, decimalsMax)
      };
    }
    var currencies = {
      USD: makeCurrency({
        symbol: "$",
        symbolWithCode: "$ USD",
        decimalsMax: 2,
        formatCurrency: (amount) => "$" + amount
      }),
      EUR: makeCurrency({
        symbol: "\u20AC",
        symbolWithCode: "\u20AC EUR",
        decimalsMax: 2,
        formatCurrency: (amount) => "\u20AC" + amount
      }),
      BTC: makeCurrency({
        symbol: "\u0243",
        symbolWithCode: "\u0243 BTC",
        decimalsMax: DECIMALS_MAX,
        formatCurrency: (amount) => amount + "\u0243"
      })
    };
    var currencies_default = currencies;

    // frontend/model/contracts/shared/distribution/distribution.js
    var tinyNum = 1 / Math.pow(10, DECIMALS_MAX);
    function unadjustedDistribution({ haveNeeds = [], minimize = true }) {
      const distribution = mincomeProportional(haveNeeds);
      return minimize ? minimizeTotalPaymentsCount(distribution) : distribution;
    }
    function adjustedDistribution({ distribution, payments, dueOn }) {
      distribution = cloneDeep(distribution);
      for (const todo of distribution) {
        todo.total = todo.amount;
      }
      distribution = subtractDistributions(distribution, payments).filter((todo) => todo.amount >= tinyNum);
      for (const todo of distribution) {
        todo.amount = saferFloat(todo.amount);
        todo.total = saferFloat(todo.total);
        todo.partial = todo.total !== todo.amount;
        todo.isLate = false;
        todo.dueOn = dueOn;
      }
      return distribution;
    }
    function reduceDistribution(payments) {
      payments = cloneDeep(payments);
      for (let i = 0; i < payments.length; i++) {
        const paymentA = payments[i];
        for (let j = i + 1; j < payments.length; j++) {
          const paymentB = payments[j];
          if (paymentA.from === paymentB.from && paymentA.to === paymentB.to || paymentA.to === paymentB.from && paymentA.from === paymentB.to) {
            paymentA.amount += (paymentA.from === paymentB.from ? 1 : -1) * paymentB.amount;
            paymentA.total += (paymentA.from === paymentB.from ? 1 : -1) * paymentB.total;
            payments.splice(j, 1);
            j--;
          }
        }
      }
      return payments;
    }
    function addDistributions(paymentsA, paymentsB) {
      return reduceDistribution([...paymentsA, ...paymentsB]);
    }
    function cloneDeep(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    function subtractDistributions(paymentsA, paymentsB) {
      paymentsB = cloneDeep(paymentsB);
      for (const p of paymentsB) {
        p.amount *= -1;
        p.total *= -1;
      }
      return addDistributions(paymentsA, paymentsB);
    }
  </script>
  <script type="text/javascript">
    function getFormat() {
      function File() { }
      File.prototype = function () {
        this.name = ""
        this.data = ""
      }
      function OpenGLDimension() {
        this.type = ""
        this.value = ""
        this.Type = {
          UNSET: "",
          SCREEN_SIZE: "SCREEN_SIZE",
          NEXT_LOWEST_POWER_OF_TWO: "NEXT_LOWEST_POWER_OF_TWO",
          NEXT_HIGHEST_POWER_OF_TWO: "NEXT_HIGHEST_POWER_OF_TWO",
          EXACT: "EXACT"
        }
      }
      OpenGLDimension.prototype = function () {
      }
      function OpenGLUniform() {
        this.type = ""
        this.name = ""
        this.value = ""
        this.Type = {
          UNSET: "",
          FLOAT: "FLOAT",
          INT: "INT",
          BOOL: "BOOL",
          VEC_TWO: "VEC_TWO",
          VEC_THREE: "VEC_THREE",
          VEC_FOUR: "VEC_FOUR",
          IVEC_TWO: "IVEC_TWO",
          IVEC_THREE: "IVEC_THREE",
          IVEC_FOUR: "IVEC_FOUR",
          BVEC_TWO: "BVEC_TWO",
          BVEC_THREE: "BVEC_THREE",
          BVEC_FOUR: "BVEC_FOUR",
          MAT_TWO: "MAT_TWO",
          MAT_THREE: "MAT_THREE",
          MAT_FOUR: "MAT_FOUR",
          SAMPLER_TWO_D: "SAMPLER_TWO_D",
          SAMPLERCUBE: "SAMPLERCUBE"
        }
      }
      OpenGLUniform.prototype = function () {
      }

      function OpenGLContext() {
        this.name = ""
        this.width = new OpenGLDimension()
        this.height = new OpenGLDimension()
        this.depth_test = false
      }
      OpenGLContext.prototype = function () {
      }

      function OpenGLProgram() {
        this.name = ""
        this.dynamics = [new GLSLJS()];
        this.uniforms = [new OpenGLUniform()]
        this.fragment = ""
        this.vertex = ""
      }

      OpenGLProgram.prototype = function () {
      }

      function GLSLJS() {
        this.name = ""
        this.value = ""
      }
      GLSLJS.prototype = function () {
      }


      function OpenGLStage() {
        this.name = ""
        this.type = ""
        this.context = ""
        this.program = ""
        this.vertices = ""
        this.indices = ""
        this.Type = {
          UNSET: "",
          SHADER: "SHADER",
          MESH_POINTS: "MESH_POINTS",
          MESH_LINES: "MESH_LINES",
          MESH_LINE_STRIP: "MESH_LINE_STRIP",
          MESH_LINE_LOOP: "MESH_LINE_LOOP",
          MESH_TRIANGLES: "MESH_TRIANGLES",
          MESH_TRIANGLE_FAN: "MESH_TRIANGLE_FAN",
          MESH_TRIANGLE_STRIP: "MESH_TRIANGLE_STRIP"
        }
      }
      OpenGLStage.prototype = function () {
      }

      function OpenGLPipeline() {
        this.contexts = [new OpenGLContext()]
        this.programs = [new OpenGLProgram()]
        this.stages = [new OpenGLStage()]
      }
      OpenGLPipeline.prototype = function () {
      }

      function Algorithm() {
        this.name = ""
        this.description = ""
        this.created = ""
        this.views = 0
        this.featured = false
        this.featured = false
        this.public = false
        this.html = ""
        this.client = ""
        this.files = [new File()]
        this.pipeline = new OpenGLPipeline()
        this.created = ""
        this.edited = ""
      }
      Algorithm.prototype = function () {
      }

      return {
        File: new File(),
        OpenGLDimension: new OpenGLDimension(),
        OpenGLUniform: new OpenGLUniform(),
        OpenGLContext: new OpenGLContext(),
        OpenGLProgram: new OpenGLProgram(),
        GLSLJS: new GLSLJS(),
        OpenGLStage: new OpenGLStage(),
        OpenGLPipeline: new OpenGLPipeline()
      }
      // Format.format = function(obj) {
      //   const final = {}
      //   for(const format in Format) {
      //     if()
      //     for(const key in Format.Algorithm) {
      //       if(typeof Format[key] === "string" && typeof obj[key] === "string") final[key].prototype = obj[key]
      //       else if(typeof Algorithm[key] === "boolean" && typeof obj[key] === "boolean") final[key].prototype =  obj[key]
      //       else if(typeof Array.isArray(Algorithm[key]) && Array.isArray(obj[key])) final[key].prototype = obj[key].map(Format.clean)
      //       else if(typeof Algorithm[key] === "object" && typeof obj[key] === "object") final[key].prototype = Format.clean(obj[key])
      //     }
      //   }
      // }
    }
    const Format = getFormat()
  </script>
  <script type="text/javascript">
    var default_fragment_shader =
      `
  #define GLSL_INSERTION_POINT
  `
    var default_vertex_shader =
      `
  #define GLSL_INSERTION_POINT
  `
    var userAlgorithm = null;

    var pipeline = null;

    var loadedCanvasCount;

    var promptStart, showLoading, hideError, hideLoading, saveAlgorithm, getListOfLanguages, voiceToText, translateLanguage, speakTextUsingGoogleSpeaker;

    var global_frequency, global_volume;

    function str2bin(str) {
      var result = [];
      for (var i = 0; i < str.length; i++) {
        result.push(str.charCodeAt(i));
      }
      return result;
    }

    function bin2str(array) {
      return String.fromCharCode.apply(String, array);
    }

    const OpenGLDimension = Format.OpenGLDimension
    const OpenGLUniform = Format.OpenGLUniform
    const GLSLJS = Format.GLSJS
    const OpenGLStageTypes = Format.OpenGLStage.Type;

    var is_safari = (navigator.userAgent.indexOf("iPhone") > -1 || navigator.userAgent.indexOf("iPad") > -1 || navigator.userAgent.indexOf("Safari") > -1) && navigator.userAgent.indexOf("Chrome") == -1;
    // var Auth, Image, Video, Sound, Person, Comment, MetaAlgorithm, 
    //     Query, Catalog, Vote, OpenGLDimension, OpenGLUniform, OpenGLContext, 
    //     OpenGLProgram, OpenGLStage, OpenGLPipeline, AlgorithmState, 
    //     Algorithm, Custom, Error, Captcha;

    window.requestAnimFrame = (function () {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function (/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {
          window.setTimeout(callback, 1000 / 60);
        };
    })();


    var api_names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];

    var OpenGLPipeline = function (pipleline_proto) { // "Constructor."
      this.currentContext = 0;
      this.contexts = [];

      if (pipleline_proto.contexts)
        for (var i = 0; i < pipleline_proto.contexts.length; i++) {
          this.addContext(pipleline_proto.contexts[i]);
          this.contexts[i].canvas.style.zIndex = i - pipleline_proto.contexts.length;
        }

      this.programs = [];
      this.cached_programs = [];

      if (pipleline_proto.programs)
        for (var i = 0; i < pipleline_proto.programs.length; i++)
          this.addProgram(pipleline_proto.programs[i]);

      this.stages = [];
      this.cached_stages = [];

      if (pipleline_proto.stages)
        for (var i = 0; i < pipleline_proto.stages.length; i++)
          this.addStage(pipleline_proto.stages[i]);
    };

    OpenGLPipeline.prototype.addContext = function (context_proto) {
      var context = new OpenGLContext(context_proto);
      this.contexts.push(context);
    };

    OpenGLPipeline.prototype.addProgram = function (program_proto) {
      var program = new OpenGLProgram(program_proto);
      this.programs.push(program);
    };

    OpenGLPipeline.prototype.addStage = function (stage_proto) {
      var stage = new OpenGLStage(stage_proto);
      this.stages.push(stage);
    };

    OpenGLPipeline.prototype.renderLoop = function () {
      this.currentContext++;
      this.anim = {
        renderLoop: (function (x) {
          if (window.renderLoop) window.renderLoop();
          this.render();
          if (x == this.currentContext)
            window.requestAnimationFrame(this.anim.renderLoop.bind(this.anim, x));
        }).bind(this)
      };
      this.anim.renderLoop(this.currentContext);
    }
    OpenGLPipeline.prototype.getProgram = function (name) {

      for (var i = 0; i < this.programs.length; i++)
        if (this.programs[i].program.name == name)
          return this.programs[i];
      return null;
    }
    OpenGLPipeline.prototype.getContext = function (name) {
      for (var i = 0; i < this.contexts.length; i++)
        if (this.contexts[i].context.name == name)
          return this.contexts[i];
      return null;
    }

    OpenGLPipeline.prototype.render = function (stage_name) {
      for (var i = 0; i < this.stages.length; i++) {
        if (stage_name && this.stages[i].stage.name != stage_name)
          continue;
        this.getContext(this.stages[i].stage.context).render(this.getProgram(this.stages[i].stage.program), this.stages[i]);
      }
    }

    OpenGLPipeline.prototype.destroy = function () {
      this.currentContext++;

      for (var i = 0; i < this.stages.length; i++)
        this.stages[i].destroy();

      this.stages = [];
    }

    OpenGLPipeline.prototype.setProto = function (new_proto) {

      //this.destroy();

      var new_contexts = new_proto.contexts;

      if (new_contexts) {
        this.contexts = []

        while (this.contexts.length < new_contexts.length)
          this.contexts.push(new OpenGLContext());


        for (var i = 0; i < new_contexts.length; i++)
          this.contexts[i].setProto(new_contexts[i]);
      }


      var new_programs = new_proto.programs;

      if (new_programs) {
        if (this.programs) {
          if (this.programs.length > new_programs.length) {
            var spliced = this.programs.splice(new_programs.length, this.programs.length - new_programs.length);
            for (var i = 0; i < spliced.length; i++)
              this.cached_programs.push(spliced[i]);
          }
          else if (this.programs.length == new_programs.length) {
            //NO OP
          }
          else {
            while (this.cached_programs.length > 0 && this.programs.length < new_programs.length)
              this.programs.push(this.cached_programs.splice(0, 1)[0]);
            while (this.programs.length < new_programs.length)
              this.programs.push(new OpenGLProgram());
          }

          for (var i = 0; i < new_programs.length; i++)
            this.programs[i].setProto(new_programs[i]);
        }
      }


      var new_stages = new_proto.stages;

      if (new_stages) {
        this.stages = []
        while (this.stages.length < new_stages.length)
          this.stages.push(new OpenGLStage());
        for (var i = 0; i < new_stages.length; i++)
          this.stages[i].setProto(new_stages[i]);
      }
    }

    var OpenGLContext = function (context_proto) { // "Constructor."

      this.context = context_proto ? context_proto : {};
      errorCode = { error: "", code: "" };
      this.gl = null;
      this.setProto(context_proto ? context_proto : {});
    };

    OpenGLContext.prototype.setProto = function (context_proto) {
      this.context = context_proto;

      if (!this.canvas) {
        this.canvas = document.createElement('canvas');
      }

      if (!context_proto.name) {
        var newId = 'canvas' + (new Date().getTime());
        this.canvas.id = newId;
        this.context.name = newId;
      }
      else {
        this.canvas.id = context_proto.name;
        this.context.name = context_proto.name;
      }

      if (!context_proto.width) {
        var newWidth = {}
        newWidth.type = OpenGLDimension.Type.SCREEN_SIZE;
        this.context.width = newWidth;
      }
      else {
        this.context.width = context_proto.width;
      }

      if (!context_proto.height) {
        var newHeight = {}
        newHeight.type = OpenGLDimension.Type.SCREEN_SIZE;
        this.context.height = newHeight;
      }
      else {
        this.context.height = context_proto.height;
      }


      if (context_proto.images)
        this.setImages(context_proto.images);

      this.textures = [];

      if (this.context.width.type == OpenGLDimension.Type.EXACT)
        this.cached_width_eval = new Function(this.context.width.value);

      if (this.context.height.type == OpenGLDimension.Type.EXACT)
        this.cached_height_eval = new Function(this.context.height.value);

      this.initGL();

      this.resizeCanvas();


      window.document.body.append(this.canvas)
    }


    OpenGLContext.prototype.setImages = function (images) {
      if (images)
        this.context.images = images;
      else
        this.context.images = [];

      this.refreshImages();
    };
    OpenGLContext.prototype.refreshImages = function () {
      this.img_elements = [];

      var x = document.getElementsByClassName("loaded-image");
      var i;
      for (i = 0; i < x.length; i++) {
        x[i].parentElement.removeChild(x[i]);
      }

      loadedCanvasCount = 0;
      for (var i = 0; i < this.context.images.length; i++) {
        var img = document.createElement('img');
        img.classList.add("loaded-image");
        img.id = "loaded-image" + i;
        this.img_elements.push(img)
        img.onload = (function () {
          if ((++loadedCanvasCount) == this.context.images.length) {
            this.refreshCanvases();
          }
        }).bind(this);
        var url = this.context.images[i].url ? this.context.images[i].url : bin2str(this.context.images[i].image);
        img.src = url;
      }
    }

    OpenGLContext.prototype.refreshCanvases = function () {
      this.canvases = [];
      for (var i = 0; i < this.context.images.length; i++) {
        var canvas = document.createElement('canvas');
        var img = this.img_elements[i];
        canvas.width = img.width;
        canvas.height = img.height;
        canvas.classList.add("loaded-image");
        canvas.id = "image-canvas" + i;

        var ctx = canvas.getContext("2d");

        ctx.drawImage(img, 0, 0);
        this.canvases.push(canvas);
      }
    }

    OpenGLContext.prototype.refreshImage = function (image) {
      try {
        var img = document.getElementById("loaded-image" + (image.index));
        var canvas = document.getElementById("image-canvas" + (image.index));
        canvas.width = img.width;
        canvas.height = img.height;

        var ctx = canvas.getContext("2d",
          {
            alpha: true,
            depth: this.context.depth_test,
            stencil: false,
            antialias: false,
            premultipliedAlpha: false,
            preserveDrawingBuffer: true,
            failIfMajorPerformanceCaveat: false
          });

        if (is_safari)
          ctx.transform(1, 0, 0, -1, 0, canvas.height)

        ctx.drawImage(img, 0, 0);
      }
      catch (e) {
        console.error("Error refreshing image: " + e);
      }
    }


    OpenGLContext.prototype.destroy = function () {
      var numTextureUnits = this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS);
      for (var unit = 0; unit < numTextureUnits; ++unit) {
        this.gl.activeTexture(this.gl.TEXTURE0 + unit);
        this.gl.bindTexture(this.gl.TEXTURE_2D, null);
        this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP, null);
      }
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);
      this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null);
      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);

      this.textures = [];
      this.gl.deleteBuffer(this.vertex_buffer);
      this.gl.deleteBuffer(this.index_buffer);
      delete this.canvas;
      this.canvas = null;
      delete this.gl;
      this.gl = null;
    }
    OpenGLContext.prototype.initGL = function () {
      this.time = 0;
      this.lastTime = 0;

      this.fpsElapsedTime = 0;
      this.fpsFrameCount = 0;
      this.fpsLastTime = new Date().getTime();
      if (this.canvas && !this.gl) {
        for (var ii = 0; ii < api_names.length; ++ii) {
          try {
            this.gl = this.canvas.getContext(api_names[ii],
              {
                alpha: true,
                depth: this.context.depth_test,
                stencil: false,
                antialias: false,
                premultipliedAlpha: false,
                preserveDrawingBuffer: true,
                failIfMajorPerformanceCaveat: false
              });
            this.gl.getExtension("OES_standard_derivatives");
            this.gl.getExtension("EXT_frag_depth");
            this.gl.getExtension('OES_texture_float');
            // this.glgetExtension('OES_texture_float_linear');
            // this.glgetExtension("OES_element_index_uint");
            // this.glgetExtension("WEBGL_color_buffer_float");
            // this.glgetExtension("EXT_color_buffer_float");
          } catch (e) { }
          if (this.gl) {
            break;
          }
        }
      }

      if (!this.gl) {
        errorCode = { report: "", code: "" };
        errorCode.report += "Could not initialise WebGL, sorry :-(";
        console.error(errorCode.report, errorCode.code);
        return;
      }

      if (!this.context.depth_test)
        this.gl.disable(this.gl.DEPTH_TEST);
      else
        this.gl.enable(this.gl.DEPTH_TEST);
    };


    OpenGLContext.prototype.resizeCanvas = function () {


      if (this.context.width.type == OpenGLDimension.Type.SCREEN_SIZE) {
        this.computed_width = window.innerWidth;
      }
      else if (this.context.width.type == OpenGLDimension.Type.NEXT_LOWEST_POWER_OF_TWO) {
        this.computed_width = Math.pow(2, Math.floor(Math.log(window.innerWidth) / Math.log(2.0)));
      }
      else if (this.context.width.type == OpenGLDimension.Type.NEXT_HIGHEST_POWER_OF_TWO) {
        this.computed_width = Math.pow(2, Math.floor(1. + Math.log(window.innerWidth) / Math.log(2.0)));
      }
      else if (this.context.width.type == OpenGLDimension.Type.EXACT) {
        this.computed_width = this.cached_width_eval.bind(this)(this);
      }

      if (this.context.height.type == OpenGLDimension.Type.SCREEN_SIZE) {
        this.computed_height = window.innerHeight
      }
      else if (this.context.height.type == OpenGLDimension.Type.NEXT_LOWEST_POWER_OF_TWO) {
        this.computed_height = Math.pow(2, Math.floor(Math.log(window.innerHeight) / Math.log(2.0)));
      }
      else if (this.context.height.type == OpenGLDimension.Type.NEXT_HIGHEST_POWER_OF_TWO) {
        this.computed_height = Math.pow(2, Math.floor(1. + Math.log(window.innerHeight) / Math.log(2.0)));
      }
      else if (this.context.height.type == OpenGLDimension.Type.EXACT) {
        this.computed_height = this.cached_height_eval.bind(this)(this);
      }
      this.canvas.width = this.computed_width;
      this.canvas.height = this.computed_height;

    };

    OpenGLContext.prototype.render = function (program, stage) {

      var now = new Date().getTime();
      this.fpsFrameCount++;
      this.fpsElapsedTime += (now - this.fpsLastTime);
      this.fpsLastTime = now;

      if (this.fpsFrameCount > 60) {
        var fps = this.fpsFrameCount / this.fpsElapsedTime * 1000.0;
        this.fpsFrameCount = 0;
        this.fpsElapsedTime = 0;
      }

      if (this.context.image && this.context.images) {

        if (this.reloadTextures) {

          for (var i = 0; i < this.context.images.length; i++)
            this.refreshImage(i);

          // for (var i = 0; i < this.textures.length; i++)
          //   this.gl.deleteTexture(this.textures[i]);
          // this.textures = [];

          // for (var i = 0; i < this.context.images.length; i++) {
          //   if (!this.img_elements[i])
          //     return;

          //   var texture = this.gl.createTexture();
          //   this.gl.bindTexture(this.gl.TEXTURE_2D, texture);

          //   // Set the parameters so we can render hany size image.
          //   this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
          //   this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
          //   this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
          //   this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);

          //   // Upload the image into the texture.
          //   this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.img_elements[i]);

          //   // add the texture to the array of textures.    
          //   this.textures.push(texture);
          // }
          this.reloadTextures = false;
        }
      }


      ////////////////////////////////////////////////////////////////////////////////////////////////////

      //this.gl.clear(this.gl.DEPTH_BUFFER_BIT | this.gl.COLOR_BUFFER_BIT);

      if (!this.cached_programs)
        this.cached_programs = {};

      if (program.dynamicsChanged(this) || !this.cached_programs[program.program.name + '-' + this.context.name]) {
        this.cached_programs[program.program.name + '-' + this.context.name] = program.getProgram(this);
        if (!this.cached_programs[program.program.name + '-' + this.context.name])
          throw new Error();
      }

      this.gl.useProgram(this.cached_programs[program.program.name + '-' + this.context.name]);
      stage.refreshGeometry(this, program);
      program.setUniforms(this, stage);
      this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
      stage.drawMesh(this, program);
    }

    var OpenGLProgram = function (program_proto) { // "Constructor."

      this.program = program_proto ? program_proto : {};
      errorCode = { error: "", code: "" };
      this.setProto(program_proto ? program_proto : {});
    };

    OpenGLProgram.prototype.setProto = function (program_proto) {
      this.program = program_proto;


      this.cached_uniform_evals = [];
      for (var i = 0; this.program.uniforms && i < this.program.uniforms.length; i++)
        this.cached_uniform_evals[i] = new Function(this.program.uniforms[i].value);
    }

    OpenGLProgram.prototype.setUniforms = function (context, stage) {
      var shader = context.cached_programs[this.program.name + '-' + context.context.name];
      for (var i = 0; (this.program.uniforms) && (this.cached_uniform_evals) && (i < this.program.uniforms.length) && (i < this.cached_uniform_evals.length); i++) {
        var location = context.gl.getUniformLocation(shader, this.program.uniforms[i].name);
        var type = this.program.uniforms[i].type;
        var value = this.cached_uniform_evals[i].bind(this)(context, this, stage);

        var type = this.program.uniforms[i].type;


        inner: switch (type) {
          case OpenGLUniform.Type.FLOAT:
            type = 'float';
            context.gl.uniform1f(location, value);
            break inner;
          case OpenGLUniform.Type.INT:
            type = 'int';
            context.gl.uniform1i(location, value);
            break inner;
          case OpenGLUniform.Type.BOOL:
            type = 'bool';
            context.gl.uniform1i(location, value);
            break inner;
          case OpenGLUniform.Type.VEC_TWO:
            type = 'vec2';
            context.gl.uniform2f(location, value[0], value[1]);
            break inner;
          case OpenGLUniform.Type.VEC_THREE:
            type = 'vec3';
            context.gl.uniform3f(location, value[0], value[1], value[2]);
            break inner;
          case OpenGLUniform.Type.VEC_FOUR:
            type = 'vec4';
            context.gl.uniform4f(location, value[0], value[1], value[2], value[3]);
            break inner;
          case OpenGLUniform.Type.IVEC_TWO:
            type = 'ivec2';
            context.gl.uniform2i(location, value[0], value[1]);
            break inner;
          case OpenGLUniform.Type.IVEC_THREE:
            type = 'ivec3';
            context.gl.uniform3i(location, value[0], value[1], value[2]);
            break inner;
          case OpenGLUniform.Type.IVEC_FOUR:
            type = 'ivec4';
            context.gl.uniform4i(location, value[0], value[1], value[2], value[3]);
            break inner;
          case OpenGLUniform.Type.BVEC_TWO:
            type = 'bvec2';
            context.gl.uniform2i(location, value[0], value[1]);
            break inner;
          case OpenGLUniform.Type.BVEC_THREE:
            type = 'bvec3';
            context.gl.uniform3i(location, value[0], value[1], value[2]);
            break inner;
          case OpenGLUniform.Type.BVEC_FOUR:
            type = 'bvec4';
            context.gl.uniform4i(location, value[0], value[1], value[2], value[3]);
            break inner;
          case OpenGLUniform.Type.MAT_TWO:
            type = 'mat2';
            context.gl.uniformMatrix2fv(location, false, value);
            break inner;
          case OpenGLUniform.Type.MAT_THREE:
            type = 'mat3';
            context.gl.uniformMatrix3fv(location, false, value);
            break inner;
          case OpenGLUniform.Type.MAT_FOUR:
            type = 'mat4';
            context.gl.uniformMatrix4fv(location, false, value);
            break inner;
          case OpenGLUniform.Type.SAMPLER_TWO_D:
            type = 'sampler2D';
            context.gl.uniform1i(location, value);
            break inner;
          case OpenGLUniform.Type.SAMPLERCUBE:
            type = 'samplerCube';
            context.gl.uniform1i(location, value);
            break inner;
        }
      }
    }


    OpenGLProgram.prototype.getUniforms = function () {
      var str = "";
      for (var i = 0; (this.program.uniforms) && (i < this.program.uniforms.length); i++) {
        var type = this.program.uniforms[i].type;


        inner: switch (type) {
          case OpenGLUniform.Type.FLOAT: type = 'float'; break inner;
          case OpenGLUniform.Type.INT: type = 'int'; break inner;
          case OpenGLUniform.Type.BOOL: type = 'bool'; break inner;
          case OpenGLUniform.Type.VEC_TWO: type = 'vec2'; break inner;
          case OpenGLUniform.Type.VEC_THREE: type = 'vec3'; break inner;
          case OpenGLUniform.Type.VEC_FOUR: type = 'vec4'; break inner;
          case OpenGLUniform.Type.IVEC_TWO: type = 'ivec2'; break inner;
          case OpenGLUniform.Type.IVEC_THREE: type = 'ivec3'; break inner;
          case OpenGLUniform.Type.IVEC_FOUR: type = 'ivec4'; break inner;
          case OpenGLUniform.Type.BVEC_TWO: type = 'bvec2'; break inner;
          case OpenGLUniform.Type.BVEC_THREE: type = 'bvec3'; break inner;
          case OpenGLUniform.Type.BVEC_FOUR: type = 'bvec4'; break inner;
          case OpenGLUniform.Type.MAT_TWO: type = 'mat2'; break inner;
          case OpenGLUniform.Type.MAT_THREE: type = 'mat3'; break inner;
          case OpenGLUniform.Type.MAT_FOUR: type = 'mat4'; break inner;
          case OpenGLUniform.Type.SAMPLER_TWO_D: type = 'sampler2D'; break inner;
          case OpenGLUniform.Type.SAMPLERCUBE: type = 'samplerCube'; break inner;
        }


        var name = this.program.uniforms[i].name;

        str += "uniform " + type + " " + name + ";\n";
      }
      return str;
    }


    OpenGLProgram.prototype.getTemplateVertexShader = function (context) {
      var str = default_vertex_shader + ""

      var delimeter = "#define GLSL_INSERTION_POINT";
      var head = str.substring(0, str.indexOf(delimeter));
      var tail = str.substring(str.indexOf(delimeter) + delimeter.length);
      var custom = this.program.vertex;

      str = head + "\n" + delimeter + "\n" + custom + "\n" + tail;

      delimeter = "#define UNIFORM_INSERTION_POINT";
      var line = str.indexOf(delimeter);
      if (line >= 0) {
        head = str.substring(0, line);
        tail = str.substring(line + delimeter.length);
        var uniforms = this.getUniforms();
        str = head + "\n" + delimeter + "\n" + uniforms + "\n" + tail;
      }

      var index = 0;
      if (this.program.dynamics) for (const glsljs of this.program.dynamics) {
        var value = this.program.cached_dynamic_strings[index]
        var delimeter = glsljs.name;
        var line = str.indexOf(delimeter);
        while (line >= 0) {
          head = str.substring(0, line);
          tail = str.substring(line + delimeter.length);
          str = head + value + tail;
          line = str.indexOf(delimeter)
        }
        index++;
      };

      var shader;
      shader = context.gl.createShader(context.gl.VERTEX_SHADER);

      context.gl.shaderSource(shader, str);
      context.gl.compileShader(shader);

      if (!context.gl.getShaderParameter(shader, context.gl.COMPILE_STATUS)) {
        errorCode.report += "Vertex Shader for CANVAS_ID=#" + this.program.canvas_id + " Error:\n\n";
        errorCode.report += context.gl.getShaderInfoLog(shader);
        errorCode.report += "\n\n\n";

        var transpiled = "";
        var lines = str.split('\n');

        for (var i = 0; i < lines.length; i++) {
          transpiled += (i + 1) + ":\t" + lines[i] + "\n";
        }

        errorCode.code += "Vertex Shader Code:\n\n";
        errorCode.code += transpiled;
        return null;
      }

      return shader;
    }
    OpenGLProgram.prototype.getTemplateFragmentShader = function (context) {
      var str = default_fragment_shader + ""

      var delimeter = "#define GLSL_INSERTION_POINT";
      var head = str.substring(0, str.indexOf(delimeter));
      var tail = str.substring(str.indexOf(delimeter) + delimeter.length);
      var custom = this.program.fragment;

      str = head + "\n" + delimeter + "\n" + custom + "\n" + tail;

      delimeter = "#define UNIFORM_INSERTION_POINT";
      var line = str.indexOf(delimeter);
      if (line >= 0) {
        head = str.substring(0, line);
        tail = str.substring(line + delimeter.length);
        var uniforms = this.getUniforms();
        str = head + "\n" + delimeter + "\n" + uniforms + "\n" + tail;
      }

      var index = 0;
      if (this.program.dynamics) for (const glsljs of this.program.dynamics) {
        var value = this.program.cached_dynamic_strings[index]
        var delimeter = glsljs.name;
        var line = str.indexOf(delimeter);
        while (line >= 0) {
          head = str.substring(0, line);
          tail = str.substring(line + delimeter.length);
          str = head + value + tail;
          line = str.indexOf(delimeter)
        }
        index++;
      };

      var shader;
      shader = context.gl.createShader(context.gl.FRAGMENT_SHADER);

      context.gl.shaderSource(shader, str);
      context.gl.compileShader(shader);

      if (!context.gl.getShaderParameter(shader, context.gl.COMPILE_STATUS)) {
        // alert(context.glgetShaderInfoLog(shader));
        errorCode.report += "Fragment Shader for CANVAS_ID=#" + this.program.canvas_id + " Error:\n\n";
        errorCode.report += context.gl.getShaderInfoLog(shader);
        errorCode.report += "\n\n\n";

        var transpiled = "";
        var lines = str.split('\n');

        for (var i = 0; i < lines.length; i++) {
          transpiled += (i + 1) + ":\t" + lines[i] + "\n";
        }

        errorCode.code += "Fragment Shader Code:\n\n";
        errorCode.code += transpiled;
        return null;
      }

      return shader;
    }
    OpenGLProgram.prototype.dynamicsChanged = function (context) {
      if (!this.program.cached_dynamic_strings) {
        this.program.cached_dynamic_functions = [];
        this.program.cached_dynamic_strings = [];
      }
      var updated = false;
      var index = 0;
      if (this.program.dynamics) for (const glsljs of this.program.dynamics) {
        this.program.cached_dynamic_functions[index] = new Function(glsljs.value);
        this.program.cached_dynamic_strings[index] = "";

        var value = this.program.cached_dynamic_functions[index]()
        if (this.program.cached_dynamic_strings[index] != value)
          updated = true;
        this.program.cached_dynamic_strings[index] = value;

        index++;
      };

      return updated;
    }
    OpenGLProgram.prototype.getProgram = function (context) {
      errorCode = { report: "", code: "" };
      var fragment_shader = this.getTemplateFragmentShader(context);
      if (!fragment_shader) {
        console.error(errorCode.report, errorCode.code);
        return;
      }

      var vertex_shader = this.getTemplateVertexShader(context);

      if (!vertex_shader) {
        console.error(errorCode.report, errorCode.code);
        return;
      }

      var shader_program = context.gl.createProgram();
      context.gl.attachShader(shader_program, fragment_shader);
      context.gl.attachShader(shader_program, vertex_shader);
      context.gl.linkProgram(shader_program);

      if (!context.gl.getProgramParameter(shader_program, context.gl.LINK_STATUS)) {
        errorCode.report += "\nUnable to link program!";
        context.gl.deleteProgram(shader_program);
        console.error(errorCode.report, errorCode.code);
      }

      context.gl.useProgram(shader_program);


      shader_program.vertexAttribute = context.gl.getAttribLocation(shader_program, "vertex");
      if (shader_program.vertexAttribute > -1)
        context.gl.enableVertexAttribArray(shader_program.vertexAttribute);

      shader_program.colorAttribute = context.gl.getAttribLocation(shader_program, "color");
      if (shader_program.colorAttribute > -1)
        context.gl.enableVertexAttribArray(shader_program.colorAttribute);

      shader_program.shapeAttribute = context.gl.getAttribLocation(shader_program, "shape");
      if (shader_program.shapeAttribute > -1)
        context.gl.enableVertexAttribArray(shader_program.shapeAttribute);


      return shader_program;
    }

    var OpenGLStage = function (stage_proto) { // "Constructor."

      this.stage = stage_proto ? stage_proto : {};
      this.setProto(stage_proto ? stage_proto : {});
    };
    OpenGLStage.prototype.setProto = function (stage_proto) {
      this.stage = stage_proto;

      this.cached_vertices = new Function(this.stage.vertices);
      this.cached_indices_eval = new Function(this.stage.indices);
    };

    OpenGLStage.prototype.drawMesh = function (context, program) {
      if (this.stage.type == OpenGLStageTypes.SHADER)
        context.gl.drawElements(context.gl.TRIANGLE_STRIP, this.index_buffer.numItems, context.gl.UNSIGNED_SHORT, 0);
      else if (this.stage.type == OpenGLStageTypes.MESH_POINTS)
        context.gl.drawElements(context.gl.POINTS, this.index_buffer.numItems, context.gl.UNSIGNED_SHORT, 0);
      else if (this.stage.type == OpenGLStageTypes.MESH_LINES)
        context.gl.drawElements(context.gl.LINES, this.index_buffer.numItems, context.gl.UNSIGNED_SHORT, 0);
      else if (this.stage.type == OpenGLStageTypes.MESH_LINE_STRIP)
        context.gl.drawElements(context.gl.LINE_STRIP, this.index_buffer.numItems, context.gl.UNSIGNED_SHORT, 0);
      else if (this.stage.type == OpenGLStageTypes.MESH_LINE_LOOP)
        context.gl.drawElements(context.gl.LINE_LOOP, this.index_buffer.numItems, context.gl.UNSIGNED_SHORT, 0);
      else if (this.stage.type == OpenGLStageTypes.MESH_TRIANGLES)
        context.gl.drawElements(context.gl.TRIANGLES, this.index_buffer.numItems, context.gl.UNSIGNED_SHORT, 0);
      else if (this.stage.type == OpenGLStageTypes.MESH_TRIANGLE_FAN)
        context.gl.drawElements(context.gl.TRIANGLE_FAN, this.index_buffer.numItems, context.gl.UNSIGNED_SHORT, 0);
      else if (this.stage.type == OpenGLStageTypes.MESH_TRIANGLE_STRIP)
        context.gl.drawElements(context.gl.TRIANGLE_STRIP, this.index_buffer.numItems, context.gl.UNSIGNED_SHORT, 0);
    };



    OpenGLStage.prototype.iniAttributeBuffers = function (context) {

      if (this.vertex_buffer)
        context.gl.deleteBuffer(this.vertex_buffer);
      if (this.color_buffer)
        context.gl.deleteBuffer(this.color_buffer);
      if (this.shape_buffer)
        context.gl.deleteBuffer(this.shape_buffer);
      if (this.index_buffer)
        context.gl.deleteBuffer(this.index_buffer);
      this.vertex_buffer = null;
      this.color_buffer = null;
      this.shape_buffer = null;
      this.index_buffer = null;
      this.vertex_buffer = context.gl.createBuffer();
      this.color_buffer = context.gl.createBuffer();
      this.shape_buffer = context.gl.createBuffer();
      this.index_buffer = context.gl.createBuffer();
    }

    OpenGLStage.prototype.refreshGeometry = function (context, program) {

      if (!this.vertex_buffer || !this.color_buffer || !this.shape_buffer || !this.index_buffer)
        this.iniAttributeBuffers(context);

      var new_vertices = null;
      var new_indices = null;

      if (this.stage.type == OpenGLStageTypes.SHADER) {
        new_vertices =
          [[
            0, 0, 0.0, 1.,
            context.computed_width, 0, 0.0, 1.,
            context.computed_width, context.computed_height, 0.0, 1.,
            0, context.computed_height, 0.0, 1.
          ]];
        new_indices = [
          0, 1, 2, 0, 2, 3// Front face
        ];
      }
      else {
        new_vertices = this.cached_vertices.bind(this)(context, program, this);
        new_indices = this.cached_indices_eval.bind(this)(context, program, this);
      }

      this.vertices = new_vertices;;
      this.indices = new_indices;;

      /*
      var update = false;
    
      if(!this.vertices || this.vertices.length!=new_vertices.length || !(this.vertices.every(function(v,i) { return v === new_vertices[i]; })))
      {
        this.vertices = new_vertices;;
        update = true;
      }
    
      if(!this.indices || this.indices.length!=new_indices.length || !(this.indices.every(function(v,i) { return v === new_indices[i]; })))
      {
        this.indices = new_indices;;
        update = true;
      }
      */

      //if(update)
      {

        this.vertex_buffer.itemSize = 4;
        this.color_buffer.itemSize = 4;
        this.shape_buffer.itemSize = 4;

        var shader = context.cached_programs[program.program.name + '-' + context.context.name];

        if (this.vertices.length > 0) {
          context.gl.bindBuffer(context.gl.ARRAY_BUFFER, this.vertex_buffer);
          context.gl.bufferData(context.gl.ARRAY_BUFFER, new Float32Array(this.vertices[0]), context.gl.DYNAMIC_DRAW);
          context.gl.enableVertexAttribArray(shader.vertexAttribute);
          context.gl.vertexAttribPointer(shader.vertexAttribute, this.vertex_buffer.itemSize, context.gl.FLOAT, false, 0, 0);
        }
        if (this.vertices.length > 1) {
          context.gl.bindBuffer(context.gl.ARRAY_BUFFER, this.color_buffer);
          context.gl.bufferData(context.gl.ARRAY_BUFFER, new Float32Array(this.vertices[1]), context.gl.DYNAMIC_DRAW);
          context.gl.enableVertexAttribArray(shader.colorAttribute);
          context.gl.vertexAttribPointer(shader.colorAttribute, this.color_buffer.itemSize, context.gl.FLOAT, false, 0, 0);
        }
        if (this.vertices.length > 2) {
          context.gl.bindBuffer(context.gl.ARRAY_BUFFER, this.shape_buffer);
          context.gl.bufferData(context.gl.ARRAY_BUFFER, new Float32Array(this.vertices[2]), context.gl.DYNAMIC_DRAW);
          context.gl.enableVertexAttribArray(shader.shapeAttribute);
          context.gl.vertexAttribPointer(shader.shapeAttribute, this.shape_buffer.itemSize, context.gl.FLOAT, false, 0, 0);
        }

        context.gl.bindBuffer(context.gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);
        context.gl.bufferData(context.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.indices), context.gl.DYNAMIC_DRAW);
        this.index_buffer.itemSize = 1;
        this.index_buffer.numItems = this.indices.length;
      }
    }
    var reloadTextures = false;

    function reload_algorithm() {

      if (pipeline) {
        //pipeline.destroy();
        if (userAlgorithm && userAlgorithm.pipeline)
          pipeline.setProto(userAlgorithm.pipeline)
      }
      else {
        if (userAlgorithm && userAlgorithm.pipeline)
          pipeline = new OpenGLPipeline(userAlgorithm.pipeline);
      }

      // if (userAlgorithm &&
      //   userAlgorithm.html) {
      //   $(document.body).append(userAlgorithm.html);
      // }

      // if (userAlgorithm != undefined &&
      //   userAlgorithm != null &&
      //   userAlgorithm.client != undefined) {
      //   document.head.innerHTML += '<script>' +
      //     userAlgorithm.client + "<script>";
      //   eval.call(window, userAlgorithm.client)
      // }

      if (pipeline)
        pipeline.renderLoop();
    }
  </script>
  <script type="text/javascript">
    window.algorithm = {
      "name": "Temporal Fairness Algorithm",
      "public": true,
      "state": {
        "html": true,
        "client": true,
        "server": false
      },
      "pipeline": {
        "contexts": [
          {
            "name": "image-context",
            "width": {
              "type": "NEXT_HIGHEST_POWER_OF_TWO",
              "value": ""
            },
            "height": {
              "type": "NEXT_HIGHEST_POWER_OF_TWO",
              "value": ""
            }
          }
        ],
        "programs": [
          {
            "name": "background-program",
            "uniforms": [
              {
                "type": "FLOAT",
                "name": "width",
                "value": "return pipeline.getContext('image-context').canvas.width;"
              },
              {
                "type": "FLOAT",
                "name": "height",
                "value": "return pipeline.getContext('image-context').canvas.height;"
              },
              {
                "type": "FLOAT",
                "name": "time",
                "value": "return window.get_time();"
              },
              {
                "type": "FLOAT",
                "name": "y_scalar",
                "value": "return window.y_scalar ? window.y_scalar : 1.;"
              },
              {
                "type": "FLOAT",
                "name": "time_window",
                "value": "return window.time_window;"
              }
            ],
            "fragment": "\n#extension GL_OES_standard_derivatives : enable\nprecision highp float;\nprecision highp int;\n\n\n\n#define iResolution (vec2(width,height))\n#define fragCoord (vPosition*iResolution)\n#define fragColor (gl_FragColor)\n#define iTime time\n\n#define UNIFORM_INSERTION_POINT\n\n\n\nvarying vec2 vPosition;\n\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n\n//-----------------UTILITY MACROS-----------------\n\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.25, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\n#define zero(x) (smoothstep(-1.0/PI/E/GR, 1.0/PI/E/GR, sin(x*PI/2.0))*2.0-1.0)\n#define absMin(x,y) (abs(x) < abs(y) ? x: y)\n#define quadrant(uv) (absMin((zero(uv).x), (zero(uv).y))+floor(uv.x/2.0)+floor(uv.y/2.0))\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\nvec4 saw(vec4 x)\n{\n    return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w));\n}\n\n\n\nvoid main()\n{\n    vec2 uv = fragCoord.xy / iResolution.xy*2.-1.;\n    float start_point = 1.-smoothstep(0., .01, 1./3.-abs(uv.x));\n  \tfloat time_line = 1.-smoothstep(0., 10., saw(uv.x*time_window*3.)*iResolution.x/time_window);\n    fragColor = vec4(1.-time_line*start_point);\n  \tfragColor.a = 1.;\n}\n    \n\n  ",
            "vertex": "precision highp float;\nprecision highp int;\n\n#define UNIFORM_INSERTION_POINT\n\nattribute highp vec4 vertex; \n\nvarying vec2 vPosition;\nvoid main(void) {\n    vPosition = vertex.xy;\n    gl_Position = vec4(vPosition*2.-1., 0., 1.);\n}\n"
          },
          {
            "name": "graphs-program",
            "uniforms": [
              {
                "type": "FLOAT",
                "name": "width",
                "value": "return pipeline.getContext('image-context').canvas.width;"
              },
              {
                "type": "FLOAT",
                "name": "height",
                "value": "return pipeline.getContext('image-context').canvas.height;"
              },
              {
                "type": "FLOAT",
                "name": "time",
                "value": "return window.get_time();"
              },
              {
                "type": "VEC_TWO",
                "name": "mouse_position",
                "value": "return window.mouse_canvas_position;"
              },
              {
                "type": "FLOAT",
                "name": "max_amount",
                "value": "return window.last_max_amount"
              },
              {
                "type": "FLOAT",
                "name": "y_scalar",
                "value": "return window.y_scalar ? window.y_scalar : 1.;"
              }
            ],
            "fragment": "\n#extension GL_OES_standard_derivatives : enable\nprecision highp float;\nprecision highp int;\n\n\n\n#define iResolution (vec2(width,height))\n#define fragCoord (vPosition*iResolution)\n#define fragColor (gl_FragColor)\n#define iTime time\n\n#define UNIFORM_INSERTION_POINT\n\n\n\nvarying vec2 vPosition;\nvarying highp vec2 uv;\n\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))+2.0)*time)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.25, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\n#define zero(x) (smoothstep(-1.0/PI/E/GR, 1.0/PI/E/GR, sin(x*PI/2.0))*2.0-1.0)\n#define absMin(x,y) (abs(x) < abs(y) ? x: y)\n#define quadrant(uv) (absMin((zero(uv).x), (zero(uv).y))+floor(uv.x/2.0)+floor(uv.y/2.0))\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\nvec4 saw(vec4 x)\n{\n    return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w));\n}\n\n\n\nvoid main()\n{\n    fragColor = vec4(0.,0.,0., 1.)*(1.-smoothstep(0.,.1, saw(uv.y*uv.x*2.)));\n}\n    \n\n  ",
            "vertex": "precision highp float;\nprecision highp int;\n\n#define UNIFORM_INSERTION_POINT\n\nattribute highp vec4 vertex; \nvarying highp vec2 uv;\nvarying vec2 vPosition;\n\nvoid main(void) {\n  \tuv = vertex.zw;\n    vPosition = vertex.xy;\n    gl_Position = vec4(vPosition*2.-1., 0., 1.);\n}\n"
          },
          {
            "name": "wealth-program",
            "uniforms": [
              {
                "type": "FLOAT",
                "name": "width",
                "value": "return pipeline.getContext('image-context').canvas.width;"
              },
              {
                "type": "FLOAT",
                "name": "height",
                "value": "return pipeline.getContext('image-context').canvas.height;"
              },
              {
                "type": "FLOAT",
                "name": "time",
                "value": "return window.get_time();"
              },
              {
                "type": "VEC_TWO",
                "name": "mouse_position",
                "value": "return window.mouse_canvas_position;"
              },
              {
                "type": "FLOAT",
                "name": "max_amount",
                "value": "return window.last_max_amount"
              },
              {
                "type": "FLOAT",
                "name": "y_scalar",
                "value": "return window.y_scalar ? window.y_scalar : 1.;"
              },
              {
                "type": "FLOAT",
                "name": "time_window",
                "value": "return window.time_window;"
              }
            ],
            "fragment": "\n#extension GL_OES_standard_derivatives : enable\nprecision highp float;\nprecision highp int;\n\n\n\n#define iResolution (vec2(width,height))\n#define fragCoord (vPosition*iResolution)\n#define fragColor (gl_FragColor)\n#define iTime time\n\n#define UNIFORM_INSERTION_POINT\n\n\n\nvarying vec2 vPosition;\nvarying highp float weight;\nvarying highp float y_pos;\n\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))+2.0)*time)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.25, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\n#define zero(x) (smoothstep(-1.0/PI/E/GR, 1.0/PI/E/GR, sin(x*PI/2.0))*2.0-1.0)\n#define absMin(x,y) (abs(x) < abs(y) ? x: y)\n#define quadrant(uv) (absMin((zero(uv).x), (zero(uv).y))+floor(uv.x/2.0)+floor(uv.y/2.0))\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\nvec4 saw(vec4 x)\n{\n    return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w));\n}\n\n\n\nvoid main()\n{\n    fragColor.rgb = flux((weight/max_amount*.5+.5)*PI).rbg;//vec3(weight)*min(max(mod(weight-time+vPosition.x, 3.)-1., 0.), 1.);//vec3(flux(weight*PI).rbg);//+vPosition.x*PI));\n  \n    fragColor.a = 1.;\n}\n    \n\n  ",
            "vertex": "precision highp float;\nprecision highp int;\n\n#define UNIFORM_INSERTION_POINT\n\nattribute highp vec4 vertex; \nvarying highp float weight;\nvarying highp float y_pos;\nvarying vec2 vPosition;\n\nvoid main(void) {\n  \tweight = vertex.z;\n  \ty_pos = vertex.w;\n    vPosition = vertex.xy;\n    gl_Position = vec4(vPosition*2.-1., 0., 1.);\n}\n"
          },
          {
            "name": "payments-program",
            "uniforms": [
              {
                "type": "FLOAT",
                "name": "width",
                "value": "return pipeline.getContext('image-context').canvas.width;"
              },
              {
                "type": "FLOAT",
                "name": "height",
                "value": "return pipeline.getContext('image-context').canvas.height;"
              },
              {
                "type": "FLOAT",
                "name": "time",
                "value": "return window.get_time();"
              },
              {
                "type": "VEC_TWO",
                "name": "mouse_position",
                "value": "return window.mouse_canvas_position;"
              },
              {
                "type": "FLOAT",
                "name": "max_amount",
                "value": "return window.last_max_amount"
              },
              {
                "type": "FLOAT",
                "name": "y_scalar",
                "value": "return window.y_scalar ? window.y_scalar : 1.;"
              },
              {
                "type": "FLOAT",
                "name": "time_window",
                "value": "return window.time_window;"
              }
            ],
            "fragment": "\n#extension GL_OES_standard_derivatives : enable\nprecision highp float;\nprecision highp int;\n\n\n\n#define iResolution (vec2(width,height))\n#define fragCoord (vPosition*iResolution)\n#define fragColor (gl_FragColor)\n#define iTime time\n\n#define UNIFORM_INSERTION_POINT\n\n\n\nvarying vec2 vPosition;\nvarying highp float weight;\nvarying highp float y_pos;\n\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))+2.0)*time)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.25, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\n#define zero(x) (smoothstep(-1.0/PI/E/GR, 1.0/PI/E/GR, sin(x*PI/2.0))*2.0-1.0)\n#define absMin(x,y) (abs(x) < abs(y) ? x: y)\n#define quadrant(uv) (absMin((zero(uv).x), (zero(uv).y))+floor(uv.x/2.0)+floor(uv.y/2.0))\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\nvec4 saw(vec4 x)\n{\n    return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w));\n}\n\n\n\nvoid main()\n{\n    fragColor.rgb = flux(weight/max_amount*PI*1.5).rbg;//vec3(weight)*min(max(mod(weight-time+vPosition.x, 3.)-1., 0.), 1.);//vec3(flux(weight*PI).rbg);//+vPosition.x*PI));\n  \n  \tfloat black_line = smoothstep(0., .1/max_amount, saw(y_pos*2.));\n  \tfragColor.rgb = min(fragColor.rgb, vec3(black_line));\n    fragColor.a = .5+.5*saw(black_line*2.);\n}\n    \n\n  ",
            "vertex": "precision highp float;\nprecision highp int;\n\n#define UNIFORM_INSERTION_POINT\n\nattribute highp vec4 vertex; \nvarying highp float weight;\nvarying highp float y_pos;\nvarying vec2 vPosition;\n\nvoid main(void) {\n  \tweight = vertex.z;\n  \ty_pos = vertex.w;\n    vPosition = vertex.xy;\n    gl_Position = vec4(vPosition*2.-1., 0., 1.);\n}\n"
          },
          {
            "name": "overlay-program",
            "uniforms": [
              {
                "type": "FLOAT",
                "name": "width",
                "value": "return pipeline.getContext('image-context').canvas.width;"
              },
              {
                "type": "FLOAT",
                "name": "height",
                "value": "return pipeline.getContext('image-context').canvas.height;"
              },
              {
                "type": "FLOAT",
                "name": "time",
                "value": "return window.get_time();"
              },
              {
                "type": "FLOAT",
                "name": "y_scalar",
                "value": "return window.y_scalar ? window.y_scalar : 1.;"
              },
              {
                "type": "FLOAT",
                "name": "time_window",
                "value": "return window.time_window;"
              },
              {
                "type": "VEC_TWO",
                "name": "mouse_position",
                "value": "return window.mouse_canvas_position"
              }
            ],
            "fragment": "\n#extension GL_OES_standard_derivatives : enable\nprecision highp float;\nprecision highp int;\n\n\n\n#define iResolution (vec2(width,height))\n#define fragCoord (vPosition*iResolution)\n#define fragColor (gl_FragColor)\n#define iTime time\n\n#define UNIFORM_INSERTION_POINT\n\n\n\nvarying vec2 vPosition;\n\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n\n//-----------------UTILITY MACROS-----------------\n\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.25, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\n#define zero(x) (smoothstep(-1.0/PI/E/GR, 1.0/PI/E/GR, sin(x*PI/2.0))*2.0-1.0)\n#define absMin(x,y) (abs(x) < abs(y) ? x: y)\n#define quadrant(uv) (absMin((zero(uv).x), (zero(uv).y))+floor(uv.x/2.0)+floor(uv.y/2.0))\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\nvec4 saw(vec4 x)\n{\n    return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w));\n}\n\n\n\nvoid main()\n{\n    vec2 uv = fragCoord.xy / iResolution.xy*2.-1.;\n    float start_point = 1.-smoothstep(0., .01, 1./3.-abs(uv.x));\n  \tfloat time_line = 1.-smoothstep(0., 1./90., saw(abs(uv.x*3.*sign(uv.x)-1.+time/time_window*3.*2./3.)));\n  \tfloat flash =1.;\n    fragColor = GR*vec4(flash,flash, flash, 2.)*time_line*start_point*vec4(vec3(smoothstep(.49, .51, (sin(uv.y*y_scalar*PI/2.))*.5+.5)), 1.);\n  \tfragColor.rgb += vec3(1.-smoothstep(0., .01, length(uv-(mouse_position*2.-1.))));\n}\n    \n\n  ",
            "vertex": "precision highp float;\nprecision highp int;\n\n#define UNIFORM_INSERTION_POINT\n\nattribute highp vec4 vertex; \n\nvarying vec2 vPosition;\nvoid main(void) {\n    vPosition = vertex.xy;\n    gl_Position = vec4(vPosition*2.-1., 0., 1.);\n}\n"
          }
        ],
        "stages": [
          {
            "name": "background-stage",
            "type": "MESH_TRIANGLES",
            "context": "image-context",
            "program": "background-program",
            "vertices": "var gl = pipeline.getContext('image-context').gl\ngl.clear(gl.COLOR_BUFFER_BIT);\ngl.disable(gl.BLEND);\nreturn  [[\n  0, 0, 0.0, 1.,\n  1, 0, 0.0, 1.,\n  1, 1, 0.0, 1.,\n  0, 1, 0.0, 1.\n]];",
            "indices": "return [\n  0, 1, 2, 0, 2, 3// Front face\n];"
          },
          {
            "name": "payments-stage",
            "type": "MESH_TRIANGLES",
            "context": "image-context",
            "program": "payments-program",
            "vertices": "var gl = pipeline.getContext('image-context').gl\ngl.disable(gl.DEPTH_TEST);\ngl.enable(gl.BLEND);gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA)\n\n\n\nreturn [window.final_payment_trapezoids.flat()]",
            "indices": "var indices = []\nvar vertices = window.final_payment_trapezoids.flat();\nfor(var i = 0; i < vertices.length/4; i++)\n  indices.push(i);\nreturn indices"
          },
          {
            "name": "wealth-stage",
            "type": "MESH_TRIANGLES",
            "context": "image-context",
            "program": "wealth-program",
            "vertices": "var gl = pipeline.getContext('image-context').gl\ngl.disable(gl.DEPTH_TEST);\ngl.disable(gl.BLEND);\nreturn [window.final_wealth_trapezoids.flat()]\n",
            "indices": "var indices = []\nvar vertices = window.final_wealth_trapezoids.flat();\nfor(var i = 0; i < vertices.length/4; i++)\n  indices.push(i);\nreturn indices"
          },
          {
            "name": "graphs-stage",
            "type": "MESH_TRIANGLES",
            "context": "image-context",
            "program": "graphs-program",
            "vertices": "var gl = pipeline.getContext('image-context').gl\ngl.enable(gl.BLEND);\ngl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA)\nreturn [window.final_graphs_trapezoids.flat()]",
            "indices": "var indices = []\nvar vertices = window.final_graphs_trapezoids.flat();\nfor(var i = 0; i < vertices.length/4; i++)\n  indices.push(i);\nreturn indices"
          },
          {
            "name": "overlay-stage",
            "type": "MESH_TRIANGLES",
            "context": "image-context",
            "program": "overlay-program",
            "vertices": "var gl = pipeline.getContext('image-context').gl\ngl.enable(gl.BLEND);\ngl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA)\nreturn  [[\n  0, 0, 0.0, 1.,\n  1, 0, 0.0, 1.,\n  1, 1, 0.0, 1.,\n  0, 1, 0.0, 1.\n]];",
            "indices": "return [\n  0, 1, 2, 0, 2, 3// Front face\n];"
          }
        ]
      },
      "files": []
    };
    window.userAlgorithm = window.algorithm

    var minCome = 0.0
    
    window.time_window = 30.;
    window.uniform_start_time = ((new Date()).getTime()) / 1E3;
    window.when_group_created = window.uniform_start_time;
    window.paused = false;
    window.pause_start_time;
    window.time_dilation = 3.;
    window.get_time = function () {
      if (paused)
        return (window.pause_start_time - window.uniform_start_time) * window.time_dilation
      return ((new Date()).getTime() / 1E3 - window.uniform_start_time) * window.time_dilation;
    }

    function back() {
      var delta = (window.get_time() / time_window) % 1
      window.uniform_start_time += ((delta < .25 ? 1. : 0) + delta) * time_window / window.time_dilation;
      window.uniform_start_time = Math.max(window.when_group_created, window.uniform_start_time)
    }
    function forward() {
      var delta = 1.0001 - (window.get_time() / time_window) % 1
      window.uniform_start_time -= delta * time_window / window.time_dilation - 1. / 1E3;
    }
    function toggle_pause() {
      if (!window.paused) {
        window.pause_start_time = new Date().getTime() / 1E3
        document.getElementById("play_button").style.display='inline-block';
        document.getElementById("pause_button").style.display='hidden';
      }
      else {
        window.uniform_start_time += new Date().getTime() / 1E3 - window.pause_start_time
        window.show_option("");
        document.getElementById("play_button").style.display='hidden';
        document.getElementById("pause_button").style.display='inline-block';
      }
      window.paused = !window.paused;
    }
    function pause() {
      if (!window.paused)
        toggle_pause();
    }

    function unpause() {
      if (window.paused)
        toggle_pause();
    }

    window.pledgers = []
    window.receivers = []

    window.user_counter = 1;
    window.event_list = []

    var EVENT_TYPES = {
      JOIN: "JOIN",
      LEAVE: "LEAVE",
      PAYMENT: "PAYMENT",
      CHANGE_INCOME: "CHANGE_INCOME",
      CHANGE_MINCOME: "CHANGE_MINCOME",
      MONTHLY_BALANCE: "MONTHLY_BALANCE"
    }

    function pledger_by_name(name) {
      var pledger = null
      for (var i = 0; i < window.pledgers.length; i++)
        if (window.pledgers[i].name == name)
          pledger = window.pledgers[i]
      return pledger;
    }
    function receiver_by_name(name) {
      var receiver = null
      for (var i = 0; i < window.receivers.length; i++)
        if (window.receivers[i].name == name)
          receiver = window.receivers[i]
      return receiver;
    }

    function find_event_index(when = window.get_time()) {
      for (var i = 0; i < window.event_list.length - 1; i++) {
        if (when >= window.event_list[i].when && when < window.event_list[i + 1].when)
          return i;
      }
      return window.event_list.length;
    }

    function user_join_event(income_or_expenses, when = window.get_time()) {
      var user_index = window.user_counter++
      window.event_list.push({ type: EVENT_TYPES.JOIN, name: user_index, when, income: income_or_expenses })
      window.event_list = window.event_list.sort((a, b) => a.when - b.when)
    }
    function user_leave_event(user_name, when = window.get_time()) {
      window.event_list.push({ type: EVENT_TYPES.LEAVE, name: user_name, when })
      window.event_list = window.event_list.sort((a, b) => a.when - b.when)
      document.getElementById('options_div').style.display='hidden'
    }

    function user_pay_event(from, to, amount, when = window.get_time()) {
      window.event_list.push({ type: EVENT_TYPES.PAYMENT, from, to, amount, when })
      window.event_list = window.event_list.sort((a, b) => a.when - b.when)
    }
    function user_change_income_event(user_name, income_or_expenses, when = window.get_time()) {
      window.event_list.push({ type: EVENT_TYPES.CHANGE_INCOME, name: user_name, income: income_or_expenses, when })
      window.event_list = window.event_list.sort((a, b) => a.when - b.when)
      document.getElementById('options_div').style.display='hidden'

    }
    function group_change_income_event(new_mincome, when = window.get_time()) {

    }
    function monthly_balance_event(for_month = Math.floor(window.get_time() / time_window)) {
      var event = window.event_list.filter((e) => e.type == EVENT_TYPES.MONTHLY_BALANCE && Math.floor(e.when / time_window) == for_month)[0]
      if (event) {
        return;
      }
      window.event_list.push({ type: EVENT_TYPES.MONTHLY_BALANCE,
        when: for_month * time_window, pledgers: window.pledgers, receivers: window.receivers })
      window.event_list = window.event_list.sort((a, b) => a.when - b.when)
    }

    do {
      user_join_event(5 + 5. * Math.pow(Math.random(), 2.), Math.random() * 30.)
    } while (Math.random() > .25)
    do {
      user_join_event(-5 - 5. * Math.pow(Math.random(), 2.), Math.random() * 30.)
    } while (Math.random() > .25)

    // window.pledgers = window.pledgers.sort((a, b) => { return b.pledge - a.pledge })
    // window.receivers = window.receivers.sort((a, b) => { return b.receive - a.receive })

    function get_amount() {
      var amount = Number(document.getElementById("amount").value)
      //$("#amount").val(Math.random())
      return amount
    }

    function get_distribution(pledgers, receivers) {
      return adjustedDistribution({
        distribution: unadjustedDistribution({haveNeeds: [
          pledgers, 
          receivers.map(r=>{
            var s = cloneDeep(r);
            s.haveNeed *= -1.;
            return s;
          })].flat(),
          minimize:true
        }), payments: window.current_monthly_payments, dueOn: 0});
    }

    function add_pledger() {
      user_join_event(get_amount())
    }
    function add_receiver() {
      user_join_event(-get_amount())
    }

    function clear_all() {
      window.last_graphs_trapezoids = [[], []]
      window.last_wealth_trapezoids = [[], []]
      window.last_payment_trapezoids = [[], [], [], []]

      window.final_payment_trapezoids = []
      window.final_wealth_trapezoids = []
      window.final_graphs_trapezoids = []

      window.pledgers = []
      window.receivers = []
      window.event_list = []
      window.user_counter = 1;
      window.uniform_start_time = ((new Date()).getTime()) / 1E3;
      window.pause_start_time = window.uniform_start_time
    }



    window.mouse_page_position = [0, 0]
    window.mouse_canvas_position = [0, 0]
    
    window.last_graphs_trapezoids = [[], []]
    window.last_wealth_trapezoids = [[], []]
    window.last_payment_trapezoids = [[], [], [], []]
    label_html = []
    label_positions = []

    window.pledger_clicked = null;
    window.payment_clicked = null;
    window.receiver_clicked = null;
    window.mouse_busy = false;


    function vectors_are_colinear(vector_a, vector_b) {
      return Math.abs(vector_a[0] * vector_b[1] -
        vector_a[1] * vector_b[0]) < 1.E-3;

    }

    function point_in_triangle(point, triangle) {
      //compute vectors & dot products
      var cx = point[0], cy = point[1],
        t0 = triangle[0], t1 = triangle[1], t2 = triangle[2],
        v0x = t2[0] - t0[0], v0y = t2[1] - t0[1],
        v1x = t1[0] - t0[0], v1y = t1[1] - t0[1],
        v2x = cx - t0[0], v2y = cy - t0[1],
        dot00 = v0x * v0x + v0y * v0y,
        dot01 = v0x * v1x + v0y * v1y,
        dot02 = v0x * v2x + v0y * v2y,
        dot11 = v1x * v1x + v1y * v1y,
        dot12 = v1x * v2x + v1y * v2y

      // Compute barycentric coordinates
      var b = (dot00 * dot11 - dot01 * dot01),
        inv = b === 0 ? 0 : (1 / b),
        u = (dot11 * dot02 - dot01 * dot12) * inv,
        v = (dot00 * dot12 - dot01 * dot02) * inv
      return !vectors_are_colinear([v0x, v0y], [v1x, v1y]) && u >= 0 && v >= 0 && (u + v < 1)
    }

    var elapsed_time,
      month_ratio,
      total_members,
      total_connections,
      totalHave,
      totalNeed,
      max_wealth,
      spacer_scalar,
      max_transferable,
      current_pledge,
      label_html,
      label_positions,
      current_receive;

    function max_height(list) {
      return list.reduce((a, v) => {
        return Math.max(a, v[1])
      }, -1E32)
    }
    function min_height(list) {
      return list.reduce((a, v) => {
        return Math.min(a, v[1])
      }, 1E32)
    }

    function max_minus_min(list) {
      return max_height(list) - min_height(list);
    }

    function refresh_default_metrics() {
      elapsed_time = window.get_time();
      month_ratio = elapsed_time / window.time_window
      elapsed_time = Math.floor(1. + elapsed_time)
      total_members = window.pledgers.length + window.receivers.length
      total_connections = window.pledgers.length * window.receivers.length
      parse_events();
      totalHave = all_pledger_heights().reduce((a, b) => a + max_height(b), 0)
      totalNeed = all_receiver_heights().reduce((a, b) => a + max_height(b), 0)
      max_wealth = Math.max(totalHave, totalNeed)
      spacer_scalar = 1.1;
      max_transferable = max_wealth*spacer_scalar

      window.y_scalar = max_transferable;

      var minHave = Math.abs(all_pledger_heights().reduce((a, b) => { return Math.min(a, min_height(b)) }, 0))
      var minNeed = Math.abs(all_receiver_heights().reduce((a, b) => { return Math.min(a, min_height(b)) }, 0))
      current_pledge = 0

      window.pledgers = window.pledgers.map((a) => { a.monthly_aggregation = 0; a.monthly_aggregation_start = 0; a.monthly_aggregation_end = 0; return a; })

      label_html = [];
      label_positions = [];
      
      current_receive = 0

      window.receivers = window.receivers.map((a) => { a.monthly_aggregation = 0; a.monthly_aggregation_start = 0; a.monthly_aggregation_end = 0; return a; })
    }
    function all_pledger_heights(for_month = Math.floor(get_time() / time_window)) {
      var heights = []
      for (var i = 0; i < window.pledgers.length; i++) {
        var weights = window.pledgers[i].money_heights
        if (weights.length > 0)
          heights.push(weights)
        else
          heights.push([0., 0.])
      }
      return heights
    }
    function all_receiver_heights(for_month = Math.floor(get_time() / time_window)) {
      var heights = []
      for (var i = 0; i < window.receivers.length; i++) {
        var weights = window.receivers[i].money_heights
        if (weights.length > 0)
          heights.push(weights)
        else
          heights.push([0., 0.])
      }
      return heights
    }

    function get_pledger_or_receiver(name) {
      for (var i = 0; i < window.pledgers.length; i++)
        if (window.pledgers[i].name == name)
          return window.pledgers[i]
      for (var i = 0; i < window.receivers.length; i++)
        if (window.receivers[i].name == name)
          return window.receivers[i]
      return undefined;
    }

    function parse_events(full_region = false, for_month = Math.floor(get_time() / time_window)) {
      window.pledgers = []
      window.receivers = []
      var thread_safe_events = JSON.parse(JSON.stringify(window.event_list))
      event_parse_loop: for (var j = 0; j < thread_safe_events.length; j++) {
        var event = thread_safe_events[j];
        if (event.when && (event.when > window.get_time() || Math.floor(event.when / time_window) != for_month))
          continue;

        if (event.type == EVENT_TYPES.JOIN) {
          var income_or_expenses = event.income
          if (income_or_expenses > 0) {
            window.pledgers.push({ name: event.name, pledge: event.income, joined: event.when, monthly_aggregation: 0, monthly_aggregation_start: 0, monthly_aggregation_end: 0, trapezoids: [] });
          }
          else {
            window.receivers.push({ name: event.name, receive: Math.abs(event.income), joined: event.when, monthly_aggregation: 0, monthly_aggregation_start: 0, monthly_aggregation_end: 0, trapezoids: [] });
          }
          get_pledger_or_receiver(event.name).time_variable = event.when
          get_pledger_or_receiver(event.name).income_integral = Math.abs(event.income)
          get_pledger_or_receiver(event.name).last_income = Math.abs(event.income)
          get_pledger_or_receiver(event.name).money_heights = []
          get_pledger_or_receiver(event.name).money_heights.push([get_pledger_or_receiver(event.name).time_variable, get_pledger_or_receiver(event.name).income_integral])
        }
        else if (event.type == EVENT_TYPES.LEAVE) {
          window.pledgers = window.pledgers.filter((v) => { return v.name != event.name })
          window.receivers = window.receivers.filter((v) => { return v.name != event.name })
        }
        else if (event.type == EVENT_TYPES.PAYMENT) {
          var time_difference_from = (event.when - get_pledger_or_receiver(event.from).time_variable) / time_window
          var time_difference_to = (event.when - get_pledger_or_receiver(event.to).time_variable) / time_window

          var old_from_height = get_pledger_or_receiver(event.from).last_income;// + time_difference_from * get_pledger_or_receiver(event.from).last_income;
          var old_to_height = get_pledger_or_receiver(event.to).last_income;// + time_difference_to * get_pledger_or_receiver(event.to).last_income;
          var new_from_height = old_from_height - event.amount;
          var new_to_height = old_to_height - event.amount;

          get_pledger_or_receiver(event.from).money_heights.push([event.when, old_from_height])

          get_pledger_or_receiver(event.to).money_heights.push([event.when, old_to_height])

          get_pledger_or_receiver(event.from).income_integral = new_from_height
          get_pledger_or_receiver(event.from).money_heights.push([event.when, new_from_height])
          get_pledger_or_receiver(event.from).time_variable = event.when

          get_pledger_or_receiver(event.to).income_integral = new_to_height
          get_pledger_or_receiver(event.to).money_heights.push([event.when, new_to_height])
          get_pledger_or_receiver(event.to).time_variable = event.when

          var event_time = event.when / time_window - Math.floor(get_time() / time_window)

          let trapezoid = [[event_time / 3., old_from_height, event.amount, 0],
          [1. - event_time / 3., old_to_height, event.amount, 0],
          [1. - event_time / 3., new_to_height, event.amount, 1],
          [event_time / 3., new_from_height, event.amount, 1]]
          window.current_payment_trapezoids.push({ from: event.from, to: event.to, trapezoid })
          window.current_monthly_payments.push({ from: event.from, to: event.to, amount: event.amount })
        }
        else if (event.type == EVENT_TYPES.CHANGE_INCOME) {
          var time_difference = (event.when - get_pledger_or_receiver(event.name).time_variable) / time_window
          get_pledger_or_receiver(event.name).time_variable = event.when
          get_pledger_or_receiver(event.name).money_heights.push([get_pledger_or_receiver(event.name).time_variable, get_pledger_or_receiver(event.name).income_integral])
          get_pledger_or_receiver(event.name).income_integral = Math.abs(event.income)
          get_pledger_or_receiver(event.name).last_income = Math.abs(event.income)
          get_pledger_or_receiver(event.name).money_heights.push([get_pledger_or_receiver(event.name).time_variable, get_pledger_or_receiver(event.name).income_integral])
        }
        else if (event.type == EVENT_TYPES.MONTHLY_BALANCE) {
          window.pledgers = JSON.parse(JSON.stringify(event.pledgers)).map((v) => { 
            v.time_variable = event.when;
            v.monthly_aggregation = 0;
            v.monthly_aggregation_start = 0;
            v.monthly_aggregation_end = 0;
            v.income_integral = v.pledge;
            v.money_heights = [[v.time_variable, v.pledge]];
            return v;
          })
          window.receivers = JSON.parse(JSON.stringify(event.receivers)).map((v) => {
            v.time_variable = event.when;
            v.monthly_aggregation = 0;
            v.monthly_aggregation_start = 0;
            v.monthly_aggregation_end = 0;
            v.income_integral = v.receive;
            v.money_heights = [[v.time_variable, v.receive]];
            return v;
          })
          debugger;
          window.current_payment_trapezoids = []
          window.current_monthly_payments = []
        }
      }
      for (var i = 0; i < window.pledgers.length; i++) {
        var money_heights = window.pledgers[i].money_heights
          var time_difference = (1. - (window.pledgers[i].time_variable / time_window) % 1.)
          window.pledgers[i].time_variable += time_difference * time_window
          // window.pledgers[i].income_integral = window.pledgers[i].last_income
          money_heights.push([window.pledgers[i].time_variable, window.pledgers[i].income_integral])
          window.pledgers[i].money_heights = money_heights
      }
      for (var i = 0; i < window.receivers.length; i++) {
        var money_heights = window.receivers[i].money_heights
          var time_difference = (1. - (window.receivers[i].time_variable / time_window) % 1.)
          window.receivers[i].time_variable += time_difference * time_window
          // window.receivers[i].income_integral = window.receivers[i].last_income
          money_heights.push([window.receivers[i].time_variable, window.receivers[i].income_integral])
        window.receivers[i].money_heights = money_heights
      }
    }

    function round_money(amount, digits = 2) {
      var power = Math.pow(10, digits)
      return Math.floor(amount * power) / power;
    }

    function mesh_trapezoid(trapezoid) {
      var vertices = []
      vertices.push(trapezoid[0][0]);
      vertices.push(trapezoid[0][1]);
      vertices.push(trapezoid[0][2]);
      vertices.push(trapezoid[0][3]);

      vertices.push(trapezoid[1][0]);
      vertices.push(trapezoid[1][1]);
      vertices.push(trapezoid[1][2]);
      vertices.push(trapezoid[1][3]);

      vertices.push(trapezoid[2][0]);
      vertices.push(trapezoid[2][1]);
      vertices.push(trapezoid[2][2]);
      vertices.push(trapezoid[2][3]);

      vertices.push(trapezoid[0][0]);
      vertices.push(trapezoid[0][1]);
      vertices.push(trapezoid[0][2]);
      vertices.push(trapezoid[0][3]);

      vertices.push(trapezoid[3][0]);
      vertices.push(trapezoid[3][1]);
      vertices.push(trapezoid[3][2]);
      vertices.push(trapezoid[3][3]);

      vertices.push(trapezoid[2][0]);
      vertices.push(trapezoid[2][1]);
      vertices.push(trapezoid[2][2]);
      vertices.push(trapezoid[2][3]);
      return vertices;
    }

    function mesh_is_visible(vertices) {
      for (var i = 0; i < vertices.length / 4; i++) {
        if (vertices[i * 4 + 0] > -1. && vertices[i * 4 + 0] < 2. &&
          vertices[i * 4 + 1] > -1. && vertices[i * 4 + 1] < 2.)
          return true
      }
      return false
    }

    function pledgers_geometry(full_region = false) {
      var vertices = []

      var mouse_under = false;
      for (var i = 0; i < window.pledgers.length; i++) {
        var pledger = window.pledgers[i]
        pledger.trapezoids = []
        var name = pledger.name;

        var money_heights = get_pledger_or_receiver(name).money_heights

        if (money_heights.length < 2) continue

        var max_wealth = 0
        var min_wealth = min_height(money_heights)
        //current_pledge -= min_wealth / max_transferable;
        pledger.monthly_aggregation_start = (current_pledge);
        pledger.monthly_aggregation = (current_pledge);
        for (var j = 0; j < Math.floor(money_heights.length) - 1; j+= 2) {
          var from_time = money_heights[j][0] / time_window - Math.floor(get_time() / time_window)
          var to_time = money_heights[j + 1][0] / time_window - Math.floor(get_time() / time_window)

          var from_wealth = money_heights[j][1] / max_transferable
          var to_wealth = money_heights[j + 1][1] / max_transferable

          max_wealth = Math.max(Math.max(from_wealth, to_wealth), max_wealth)

          let trapezoid = [
            [from_time / 3., current_pledge, full_region ? to_wealth : from_wealth, full_region ? current_pledge : 0],
            [to_time / 3., current_pledge, full_region ? to_wealth : from_wealth, full_region ? current_pledge : 0],
            [to_time / 3., current_pledge + to_wealth, to_wealth, full_region ? current_pledge : 1],
            [from_time / 3., current_pledge + from_wealth, from_wealth, full_region ? current_pledge : 1]]
          if (full_region) {

            var old_trapezoid = JSON.parse(JSON.stringify(trapezoid))

            var min_x = Math.min(Math.min(Math.min(old_trapezoid[0][0],
              old_trapezoid[1][0]),
              old_trapezoid[2][0]),
              old_trapezoid[3][0])
            var min_y = Math.min(Math.min(Math.min(old_trapezoid[0][1],
              old_trapezoid[1][1]),
              old_trapezoid[2][1]),
              old_trapezoid[3][1])
            var max_x = Math.max(Math.max(Math.max(old_trapezoid[0][0],
              old_trapezoid[1][0]),
              old_trapezoid[2][0]),
              old_trapezoid[3][0])
            var max_y = Math.max(Math.max(Math.max(old_trapezoid[0][1],
              old_trapezoid[1][1]),
              old_trapezoid[2][1]),
              old_trapezoid[3][1])

            trapezoid[0][0] = min_x
            trapezoid[0][1] = min_y

            trapezoid[1][0] = max_x
            trapezoid[1][1] = min_y

            trapezoid[2][0] = max_x
            trapezoid[2][1] = max_y

            trapezoid[3][0] = min_x
            trapezoid[3][1] = max_y

            if (from_wealth < 0)
              to_wealth = Math.abs(from_wealth)

            trapezoid[0][2] = to_wealth * max_transferable
            trapezoid[0][3] = 0

            trapezoid[1][2] = to_wealth * max_transferable
            trapezoid[1][3] = 0

            trapezoid[2][2] = to_wealth * max_transferable
            trapezoid[2][3] = 1

            trapezoid[3][2] = to_wealth * max_transferable
            trapezoid[3][3] = 1
          }
          var mesh = mesh_trapezoid(trapezoid);
          if (!mesh_is_visible(trapezoid.flat()))
            mesh = mesh.map((v) => Math.sign(v) * 3.)
          pledger.trapezoids.push(mesh)
          vertices.push(mesh);
          label_html.push("user" + (name) + " has " + round_money(money_heights[j][1]) + "<br>");
          var avg_x = (trapezoid[0][0]+trapezoid[1][0])/2;
          var avg_y = (trapezoid[0][1]+trapezoid[1][1]+trapezoid[2][1]+trapezoid[3][1])/4;
          label_positions.push([avg_x, avg_y])
          if (point_in_triangle(window.mouse_canvas_position, [trapezoid[0], trapezoid[1], trapezoid[2]]) ||
            point_in_triangle(window.mouse_canvas_position, [trapezoid[0], trapezoid[3], trapezoid[2]])) {
            mouse_under = true;
            window.pledger_clicked = function (pledger) {
              return function () {
                pause();

                var change_pledge = `
					  	<label style="display:inline-block;">Amount:</label>
						<input id="pledge_amount" type="number" value="`+ pledger.pledge + `" step="1" style="display:inline-block; width:64px">`

                window.show_option("User" + pledger.name + ":<br>" + change_pledge +
                  "<button onclick=\"user_change_income_event(\'" + pledger.name + "\', parseFloat(document.getElementById(\'pledge_amount\').value))\">Set Income</button>" +
                  "<br><button onclick=\"user_leave_event(\'" + pledger.name + "\')\">Make Leave</button>");
              }
            }(pledger)
          }
        }
        current_pledge += max_wealth*spacer_scalar
        pledger.monthly_aggregation_end = (current_pledge);
      }
      if (!mouse_under)
        window.pledger_clicked = null;

      return vertices.flat();
    }
    function receivers_geometry(full_region = false) {
      var vertices = []

      var mouse_under = false;
      for (var i = 0; i < window.receivers.length; i++) {
        var receiver = window.receivers[i]
        receiver.trapezoids = []

        var receiver = receiver
        var name = receiver.name;

        var money_heights = get_pledger_or_receiver(name).money_heights

        if (money_heights.length < 2) continue

        var max_wealth = 0
        var min_wealth = min_height(money_heights)
        // current_receive -= min_wealth / max_transferable;
        receiver.monthly_aggregation_start = (current_receive);
        receiver.monthly_aggregation = (current_receive);
        for (var j = 0; j < Math.floor(money_heights.length) - 1; j += 2) {
          var from_time = money_heights[j][0] / time_window - Math.floor(get_time() / time_window)
          var to_time = money_heights[j + 1][0] / time_window - Math.floor(get_time() / time_window)

          var from_wealth = money_heights[j][1] / max_transferable
          var to_wealth = money_heights[j + 1][1] / max_transferable

          max_wealth = Math.max(Math.max(from_wealth, to_wealth), max_wealth)

          let trapezoid = [[1. - from_time / 3., current_receive, full_region ? to_wealth : from_wealth, full_region ? current_pledge : 0],
          [1. - to_time / 3., current_receive, full_region ? to_wealth : from_wealth, full_region ? current_pledge : 0],
          [1. - to_time / 3., current_receive + to_wealth, to_wealth, full_region ? current_pledge : 1],
          [1. - from_time / 3., current_receive + from_wealth, from_wealth, full_region ? current_pledge : 1]]

          if (full_region) {

            var old_trapezoid = JSON.parse(JSON.stringify(trapezoid))

            var min_x = Math.min(Math.min(Math.min(old_trapezoid[0][0],
              old_trapezoid[1][0]),
              old_trapezoid[2][0]),
              old_trapezoid[3][0])
            var min_y = Math.min(Math.min(Math.min(old_trapezoid[0][1],
              old_trapezoid[1][1]),
              old_trapezoid[2][1]),
              old_trapezoid[3][1])
            var max_x = Math.max(Math.max(Math.max(old_trapezoid[0][0],
              old_trapezoid[1][0]),
              old_trapezoid[2][0]),
              old_trapezoid[3][0])
            var max_y = Math.max(Math.max(Math.max(old_trapezoid[0][1],
              old_trapezoid[1][1]),
              old_trapezoid[2][1]),
              old_trapezoid[3][1])

            trapezoid[0][0] = min_x
            trapezoid[0][1] = min_y

            trapezoid[1][0] = max_x
            trapezoid[1][1] = min_y

            trapezoid[2][0] = max_x
            trapezoid[2][1] = max_y

            trapezoid[3][0] = min_x
            trapezoid[3][1] = max_y

            if (from_wealth < 0)
              to_wealth = Math.abs(from_wealth)

            trapezoid[0][2] = to_wealth * max_transferable
            trapezoid[0][3] = 0

            trapezoid[1][2] = to_wealth * max_transferable
            trapezoid[1][3] = 0

            trapezoid[2][2] = to_wealth * max_transferable
            trapezoid[2][3] = 1

            trapezoid[3][2] = to_wealth * max_transferable
            trapezoid[3][3] = 1
          }

          var mesh = mesh_trapezoid(trapezoid);
          if (!mesh_is_visible(trapezoid.flat()))
            mesh = mesh.map((v) => Math.sign(v) * 3.)
          receiver.trapezoids.push(mesh)
          vertices.push(mesh);
          label_html.push("user" + (name) + " receives " + round_money(money_heights[j][1]) + "<br>");
          var avg_x = (trapezoid[0][0]+trapezoid[1][0])/2.;
          var avg_y = (trapezoid[0][1]+trapezoid[1][1]+trapezoid[2][1]+trapezoid[3][1])/4;
          label_positions.push([avg_x, avg_y])
          if (point_in_triangle(window.mouse_canvas_position, [trapezoid[0], trapezoid[1], trapezoid[2]]) ||
            point_in_triangle(window.mouse_canvas_position, [trapezoid[0], trapezoid[3], trapezoid[2]])) {
            mouse_under = true;
            window.receiver_clicked = function (receiver) {
              return function () {
                pause();

                var change_pledge = `
					  	<label style="display:inline-block;">Amount:</label>
						<input id="receive_amount" type="number" value="`+ receiver.receive + `" step="1" style="display:inline-block; width:64px">`

                window.show_option("User" + receiver.name + ":<br>" + change_pledge +
                  "<button onclick=\"user_change_income_event(\'" + receiver.name + "\', parseFloat(document.getElementById(\'receive_amount\').value))\">Set Income</button>" +
                  "<br><button onclick=\"user_leave_event(\'" + receiver.name + "\')\">Make Leave</button>");
              }
            }(receiver)
          }
        }
        current_receive += max_wealth*spacer_scalar
        receiver.monthly_aggregation_end = (current_receive);
      }
      if (!mouse_under)
        window.receiver_clicked = null;

      return vertices.flat();
    }

    function total_current_payments(name) {
      if (!window.current_monthly_payments) return 0;
      var total = 0
      window.current_monthly_payments.map((v) => total += (v.from == name || v.to == name) ? v.amount : 0)
      return total;
    }
    function total_current_payments_from_to(from, to) {
      if (!window.current_monthly_payments) return 0;
      var total = 0
      window.current_monthly_payments.map((v) => total += (v.from == from && v.to == to) ? v.amount : 0)
      return total;
    }

    function payments_geometry() {
      window.payment_message = ""
      window.todo_payment_trapezoids = [];
      var vertices = []
      var pledger_heights = all_pledger_heights()
      var receiver_heights = all_receiver_heights()
      if (pledger_heights.length < 1 || receiver_heights.length < 1)
        return [];
      var distribution = get_distribution(
        pledger_heights.map((a, i) => { return { name: window.pledgers[i].name, haveNeed: window.pledgers[i].pledge } }),
        receiver_heights.map((a, i) => { return { name: window.receivers[i].name, haveNeed: window.receivers[i].receive} }));
      var mouse_under = false;
      for (var i = 0; i < distribution.length; i++) {
        var payment = distribution[i]

        var pledger = pledger_by_name(payment.from)
        var receiver = receiver_by_name(payment.to)

        if (!pledger || !receiver) {
          continue
        }

        let trapezoid = [[1. / 3., pledger.monthly_aggregation, payment.amount / max_transferable, 0],
        [2. / 3., receiver.monthly_aggregation, payment.amount / max_transferable, 0],
        [2. / 3., receiver.monthly_aggregation + payment.amount / max_transferable, payment.amount / max_transferable, 1],
        [1. / 3., pledger.monthly_aggregation + payment.amount / max_transferable, payment.amount / max_transferable, 1]]

        window.todo_payment_trapezoids.push(mesh_trapezoid(trapezoid))
        vertices.push(mesh_trapezoid(trapezoid));
        label_html.push(""+round_money(payment.amount));
          var avg_x = (trapezoid[0][0]);
          var avg_y = (trapezoid[0][1]+trapezoid[3][1])/2;
          label_positions.push([avg_x, avg_y])
        if (point_in_triangle(window.mouse_canvas_position, [trapezoid[0], trapezoid[1], trapezoid[2]]) ||
          point_in_triangle(window.mouse_canvas_position, [trapezoid[0], trapezoid[3], trapezoid[2]])) {
            
          label_html.push("TODO Payment<br>From: user" + (payment.from) + "<br>To: user" + (payment.to) + "<br>Amount: " + round_money(payment.amount) + "<br> <div style='border-bottom: 1px solid #000'></div>");
          label_positions.push(window.mouse_canvas_position)
          mouse_under = true;

          var make_payment = `<label style="display:inline-block;">Amount:</label>
									<input id="payment_amount" type="number" value="`+ payment.amount + `" max="` + payment.amount + `"step="1" style="display:inline-block; width:64px">`
          window.payment_message += (window.payment_message ? "<br>" : "") + "Payment from User" + payment.from + " to User" + payment.to + "<br>" + make_payment +
            "<button onclick=\"document.getElementById('options_div').style.display='hidden'; user_pay_event(\'" + payment.from + "\', \'" + payment.to + "\', parseFloat(document.getElementById('payment_amount').value))\">Make Payment</button>"

          window.payment_clicked = function () {
            pause();
            window.show_option(window.payment_message);
          }
        }

        pledger.monthly_aggregation += payment.amount / max_transferable;
        receiver.monthly_aggregation += payment.amount / max_transferable;
      }
      if (!mouse_under)
        window.payment_clicked = null;

      return vertices.flat();
    }

    window.last_month = -1.;



    window.renderLoop = () => {



      monthly_balance_event()
      refresh_default_metrics();
      parse_events(true);
      var vertices = [pledgers_geometry(true), receivers_geometry(true)].flat().flat()

      var time = new Date().getTime() / 1E3;
      if (!window.last_trapezoid_morph)
        window.last_trapezoid_morph = time;
      window.trapezoid_morph_step = time - window.last_trapezoid_morph;
      window.last_trapezoid_morph = time;
      var maxHave = all_pledger_heights().reduce((a, b) => {
        return Math.max(a, b.reduce((a, b) => {
          return Math.max(a, Math.abs(b[1]));
        }, 0))
      }, 0)
      var maxNeed = all_receiver_heights().reduce((a, b) => {
        return Math.max(a, b.reduce((a, b) => {
          return Math.max(a, Math.abs(b[1]));
        }, 0))
      }, 0)
      var max_amount = Math.max(maxNeed, maxHave) / max_transferable;
      if (!window.last_max_amount)
        window.last_max_amount = 1;
      window.last_max_amount += (max_amount - window.last_max_amount) * window.trapezoid_morph_step * 10.
      var index = 0;
      for (var i = 0; i < window.pledgers.length; i++) {
        if (!window.last_graphs_trapezoids[0][i])
          window.last_graphs_trapezoids[0][i] = []
        var trapezoids = window.pledgers[i].trapezoids;
        var sub_index = 0;
        for (var j = 0; j < trapezoids.length; j++) {
          if (!window.last_graphs_trapezoids[0][i][j])
            window.last_graphs_trapezoids[0][i][j] = []
          var trapezoid = trapezoids[j]
          for (var k = 0; k < trapezoid.length; k++) {
            if (window.last_graphs_trapezoids[0][i][j][k] == undefined) {
              if (k % 4 == 0)
                window.last_graphs_trapezoids[0][i][j][k] = .5
              else
                window.last_graphs_trapezoids[0][i][j][k] = trapezoid[k]
            }
            var delta = (trapezoid[k] - window.last_graphs_trapezoids[0][i][j][k]);
            window.last_graphs_trapezoids[0][i][j][k] += delta * Math.max(window.trapezoid_morph_step, 1. / 10.);
          }
          sub_index++
        }
        window.last_graphs_trapezoids[0][i] = window.last_graphs_trapezoids[0][i].slice(0, sub_index)
        index++
      }
      window.last_graphs_trapezoids[0] = window.last_graphs_trapezoids[0].slice(0, index)
      var index = 0;
      for (var i = 0; i < window.receivers.length; i++) {
        if (!window.last_graphs_trapezoids[1][i])
          window.last_graphs_trapezoids[1][i] = []
        var trapezoids = window.receivers[i].trapezoids;
        var sub_index = 0
        for (var j = 0; j < trapezoids.length; j++) {
          if (!window.last_graphs_trapezoids[1][i][j])
            window.last_graphs_trapezoids[1][i][j] = []
          var trapezoid = trapezoids[j]
          for (var k = 0; k < trapezoid.length; k++) {
            if (window.last_graphs_trapezoids[1][i][j][k] == undefined) {
              if (k % 4 == 0)
                window.last_graphs_trapezoids[1][i][j][k] = .5
              else
                window.last_graphs_trapezoids[1][i][j][k] = trapezoid[k]
            }
            var delta = (trapezoid[k] - window.last_graphs_trapezoids[1][i][j][k]);
            window.last_graphs_trapezoids[1][i][j][k] += delta * Math.max(window.trapezoid_morph_step, 1. / 10.);
          }
          sub_index++
        }
        window.last_graphs_trapezoids[1][i] = window.last_graphs_trapezoids[1][i].slice(0, sub_index)
        index++
      }
      window.last_graphs_trapezoids[1] = window.last_graphs_trapezoids[1].slice(0, index)
      window.final_graphs_trapezoids = []
      for (var i = 0; i < window.last_graphs_trapezoids.length; i++)
        for (var j = 0; j < window.last_graphs_trapezoids[i].length; j++)
          for (var k = 0; k < window.last_graphs_trapezoids[i][j].length; k++)
            if (mesh_is_visible(window.last_graphs_trapezoids[i][j][k]))
              window.final_graphs_trapezoids.push(window.last_graphs_trapezoids[i][j][k])
      parse_events();
      refresh_default_metrics();
      var vertices = [pledgers_geometry(), receivers_geometry(), payments_geometry()].flat()


      var index = 0;
      for (var i = 0; i < window.pledgers.length; i++) {

        if (!window.last_wealth_trapezoids[0][i])
          window.last_wealth_trapezoids[0][i] = []
        var trapezoids = window.pledgers[i].trapezoids;
        var sub_index = 0;
        for (var j = 0; j < trapezoids.length; j++) {
          if (!window.last_wealth_trapezoids[0][i][j])
            window.last_wealth_trapezoids[0][i][j] = []
          var trapezoid = trapezoids[j]
          for (var k = 0; k < trapezoid.length; k++) {
            if (window.last_wealth_trapezoids[0][i][j][k] == undefined) {
              if (k % 4 == 0)
                window.last_wealth_trapezoids[0][i][j][k] = .5
              else
                window.last_wealth_trapezoids[0][i][j][k] = trapezoid[k]
            }
            var delta = (trapezoid[k] - window.last_wealth_trapezoids[0][i][j][k]);
            window.last_wealth_trapezoids[0][i][j][k] += delta * Math.max(window.trapezoid_morph_step, 1. / 10.);
          }
          sub_index++;
        }
        window.last_wealth_trapezoids[0][i] = window.last_wealth_trapezoids[0][i].slice(0, sub_index)
        index++
      } window.last_wealth_trapezoids[0] = window.last_wealth_trapezoids[0].slice(0, index)
      var index = 0;
      for (var i = 0; i < window.receivers.length; i++) {
        if (!window.last_wealth_trapezoids[1][i])
          window.last_wealth_trapezoids[1][i] = []
        var trapezoids = window.receivers[i].trapezoids;
        var sub_index = 0;
        for (var j = 0; j < trapezoids.length; j++) {
          if (!window.last_wealth_trapezoids[1][i][j])
            window.last_wealth_trapezoids[1][i][j] = []
          var trapezoid = trapezoids[j]
          for (var k = 0; k < trapezoid.length; k++) {
            if (window.last_wealth_trapezoids[1][i][j][k] == undefined) {
              if (k % 4 == 0)
                window.last_wealth_trapezoids[1][i][j][k] = .5
              else
                window.last_wealth_trapezoids[1][i][j][k] = trapezoid[k]
            }
            var delta = (trapezoid[k] - window.last_wealth_trapezoids[1][i][j][k]);
            window.last_wealth_trapezoids[1][i][j][k] += delta * Math.max(window.trapezoid_morph_step, 1. / 10.);
          }
          sub_index++;
        }
        window.last_wealth_trapezoids[1][i] = window.last_wealth_trapezoids[1][i].slice(0, sub_index)
        index++
      } window.last_wealth_trapezoids[1] = window.last_wealth_trapezoids[1].slice(0, index)
      var index = 0;
      for (var i = 0; i < window.current_payment_trapezoids.length; i++) {
        if (!window.last_payment_trapezoids[0][i])
          window.last_payment_trapezoids[0][i] = []
        var trapezoid_info = window.current_payment_trapezoids[i]

        var pledger = get_pledger_or_receiver(trapezoid_info.from);
        var receiver = get_pledger_or_receiver(trapezoid_info.to);

        if (!pledger || !receiver)
          continue;

        var from_aggregation = pledger.monthly_aggregation_start
        var to_aggregation = receiver.monthly_aggregation_start

        var basic_trapezoid = trapezoid_info.trapezoid

        basic_trapezoid[0][1] /= max_transferable
        basic_trapezoid[1][1] /= max_transferable
        basic_trapezoid[2][1] /= max_transferable
        basic_trapezoid[3][1] /= max_transferable

        basic_trapezoid[0][1] += from_aggregation
        basic_trapezoid[1][1] += to_aggregation
        basic_trapezoid[2][1] += to_aggregation
        basic_trapezoid[3][1] += from_aggregation

        var trapezoid = mesh_trapezoid(basic_trapezoid)

        var j = 0
        if (!window.last_payment_trapezoids[0][i][j])
          window.last_payment_trapezoids[0][i][j] = []
        for (var k = 0; k < trapezoid.length; k++) {
          if (window.last_payment_trapezoids[0][i][j][k] == undefined) {
            if (k % 4 == 0)
              window.last_payment_trapezoids[0][i][j][k] = .5
            else
              window.last_payment_trapezoids[0][i][j][k] = trapezoid[k]
          }
          var delta = (trapezoid[k] - window.last_payment_trapezoids[0][i][j][k]);
          window.last_payment_trapezoids[0][i][j][k] += delta * Math.max(window.trapezoid_morph_step, 1. / 10.);
        }
        index++
      } window.last_payment_trapezoids[0] = window.last_payment_trapezoids[0].slice(0, index)

      // var index = 0;
      // for (var i = 0; i < window.todo_payment_trapezoids.length; i++) {
      //     if (!window.last_payment_trapezoids[1][i])
      //         window.last_payment_trapezoids[1][i] = []
      //     var trapezoid = window.todo_payment_trapezoids[i]
      //     var j = 0
      //     if (!window.last_payment_trapezoids[1][i][j])
      //         window.last_payment_trapezoids[1][i][j] = []
      //     for (var k = 0; k < trapezoid.length; k++) {
      //         if (window.last_payment_trapezoids[1][i][j][k] == undefined) {
      //             if (k % 4 == 0)
      //                 window.last_payment_trapezoids[1][i][j][k] = .5
      //             else
      //                 window.last_payment_trapezoids[1][i][j][k] = trapezoid[k]
      //         }
      //         var delta = (trapezoid[k] - window.last_payment_trapezoids[1][i][j][k]);
      //         window.last_payment_trapezoids[1][i][j][k] += delta * Math.max(window.trapezoid_morph_step, 1. / 10.);
      //     }
      //     index++
      // } window.last_payment_trapezoids[1] = window.last_payment_trapezoids[1].slice(0, index)

      var index = 0;
      for (var i = 0; i < window.todo_payment_trapezoids.length; i++) {
        if (!window.last_payment_trapezoids[3][i])
          window.last_payment_trapezoids[3][i] = []
        var trapezoid = window.todo_payment_trapezoids[i]
        var j = 0
        if (!window.last_payment_trapezoids[3][i][j])
          window.last_payment_trapezoids[3][i][j] = []
        for (var k = 0; k < trapezoid.length; k++) {
          if (window.last_payment_trapezoids[3][i][j][k] == undefined) {
            if (k % 4 == 0)
              window.last_payment_trapezoids[3][i][j][k] = .5
            else
              window.last_payment_trapezoids[3][i][j][k] = trapezoid[k]
          }
          var delta = (trapezoid[k] - window.last_payment_trapezoids[3][i][j][k]);
          window.last_payment_trapezoids[3][i][j][k] += delta * Math.max(window.trapezoid_morph_step, 1. / 10.);
        }
        index++
      } window.last_payment_trapezoids[3] = window.last_payment_trapezoids[3].slice(0, index)

      if (window.show_labels) window.show_labels()

      window.final_wealth_trapezoids = []
      for (var i = 0; i < window.last_wealth_trapezoids.length; i++)
        for (var j = 0; j < window.last_wealth_trapezoids[i].length; j++)
          for (var k = 0; k < window.last_wealth_trapezoids[i][j].length; k++)
            if (mesh_is_visible(window.last_wealth_trapezoids[i][j][k]))
              window.final_wealth_trapezoids.push(window.last_wealth_trapezoids[i][j][k])

      for (var i = 0; i < window.final_wealth_trapezoids.length / 4; i++) {
        var vector = [window.final_wealth_trapezoids[i * 4 + 0],
        window.final_wealth_trapezoids[i * 4 + 1],
        window.final_wealth_trapezoids[i * 4 + 2],
        window.final_wealth_trapezoids[i * 4 + 3]]
      }

      window.final_payment_trapezoids = []
      for (var i = 0; i < window.last_payment_trapezoids.length; i++)
        for (var j = 0; j < window.last_payment_trapezoids[i].length; j++)
          for (var k = 0; k < window.last_payment_trapezoids[i][j].length; k++)
            if (mesh_is_visible(window.last_payment_trapezoids[i][j][k]))
              window.final_payment_trapezoids.push(window.last_payment_trapezoids[i][j][k])
    }
    window.onload = () => {

      window.reload_algorithm()

      var canvas = pipeline.contexts[pipeline.contexts.length - 1].canvas;

      canvas.style.position = 'relative';
      canvas.style.width = '100%';
      canvas.style.height = '100%';
      var canvas_div = document.getElementById("canvas_div");
      var label_div = document.getElementById("label_div")
      canvas_div.append(canvas);
      function res() {
        pipeline.contexts[pipeline.contexts.length - 1].resizeCanvas()
      }
      window.addEventListener('resize', res);

      function onmousemove(e) {
        window.mouse_page_position = [e.pageX, e.pageY]
        window.mouse_canvas_position = [e.pageX / canvas_div.offsetWidth, 1. - (e.pageY - canvas_div.offsetTop) / canvas_div.offsetHeight]
      };
      canvas_div.onmousemove = onmousemove
      canvas_div.onmouseup = function (e) {
        if (window.mouse_busy) return;

        if (window.pledger_clicked) window.pledger_clicked()
        else if (window.payment_clicked) window.payment_clicked()
        else if (window.receiver_clicked) window.receiver_clicked()
        else {
          unpause();
          return;
        }
        document.getElementById("pause_button").style.display = "inline-block"
      };
      var options_div = document.getElementById("options_div")
      var label_div = document.getElementById("label_div")

      options_div.onmouseenter = function (e) {
        window.mouse_busy = true;
      }
      options_div.onmouseleave = function (e) {
        window.mouse_busy = false;
      }

      window.show_option = (html)=>{
      	options_div.style.display="block"
        options_div.innerHTML = html;
        options_div.style.top= (window.mouse_page_position[1]-canvas_div.offsetTop)+ "px";
        options_div.style.left= (window.mouse_page_position[0] - options_div.offsetWidth/ 2.) + "px";
    }
      window.show_labels = () => {
        if (label_html) {
          var html = label_html.reduce((acc, html, index) => {
            var x = Math.floor(label_positions[index][0]*canvas_div.offsetWidth)
            var y = Math.floor((1.-label_positions[index][1])*canvas_div.offsetHeight)
            return acc + '<div style="transform:translate(-50%,-50%); position:absolute; display:block; left: '+x+'px; top: '+y+'px;"class="label_div">'+html+'</div>'
          }, "")
          label_div.style.display = "block"
          if(html != window.last_label_html)
          label_div.innerHTML = html;
          window.last_label_html = html;
          label_div.onmousemove = onmousemove
        }
        else
          label_div.style.display = "none"
      }

      function onmousemove(e) {
        window.mouse_page_position = [e.pageX, e.pageY]
        window.mouse_canvas_position = [e.pageX / canvas_div.offsetWidth, 1. - (e.pageY - canvas_div.offsetTop) / canvas_div.offsetHeight]
      };
      canvas_div.onmousemove = onmousemove
    }
  </script>
</head>

<body>
  <div id="top_div">
    <div class="add_pledger"
      style="position:absolute; left:0%; top:10px; width: 33%; height:95%; text-align:center;">
      <button onclick="add_pledger()">Add Pledger</button>
    </div>
    <div class="" style="position:absolute; left:33%; top:10px; width: 33%; height:95%; text-align:center;">
      <label style="display:inline-block;">Amount:</label>
      <input id="amount" type="number" value="10" min="0" step="1" style="display:inline-block; width:50%">
      </input>
    </div>
    <div id="add_receiver"
      style="position:absolute; left:66%; top:10px; width: 33%; height:95%; text-align:center;">
      <button onclick="add_receiver()">Add Receiver</button>
    </div>
  </div>
  <div id="canvas_div">
    <div style="width:100%; height: 100%; position: absolute;" id="label_div">
    </div>
    <div id="options_div">
    </div>
  </div>
  <div id="bottom_div">
    <div id="controls_div" style="position:absolute; bottom: 5px; left:0%; width: 100%; text-align:center;">
      <button style="border-color: #f00" onclick="back()">&lt;&lt;</button>
      <button id="pause_button" style="border-color: #f00" onclick="pause()">ll</button>
      <button id="play_button" style="display:none; border-color: #f00" onclick="unpause()">&gt;</button>
      <button style="border-color: #f00" onclick="forward()">&gt;&gt;</button>
      <button style="border-color: #f00" onclick="clear_all()">Clear &amp; Reset</button>
    </div>
  </div>
</body>

</html>